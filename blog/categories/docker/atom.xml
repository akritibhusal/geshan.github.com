<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | Geshan's Blog]]></title>
  <link href="https://geshan.com.np/blog/categories/docker/atom.xml" rel="self"/>
  <link href="https://geshan.com.np/"/>
  <updated>2019-10-31T23:14:42+00:00</updated>
  <id>https://geshan.com.np/</id>
  <author>
    <name><![CDATA[Geshan Manandhar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Set up Laravel 6 on Google Cloud Run step by step with Continuous Integration (CI)]]></title>
    <link href="https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci/"/>
    <updated>2019-10-21T08:03:29+00:00</updated>
    <id>https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci</id>
    <content type="html"><![CDATA[<p>Laravel has <a href="https://trends.google.com/trends/explore?date=2014-10-22%202019-10-21&amp;q=laravel,symfony">soared</a> in popularity in the last few years. The Laravel community even says that Laravel has made writing PHP enjoyable than a pain. Laravel 6 has some interesting new <a href="https://laracasts.com/series/whats-new-in-laravel-6">features</a>. Getting a super scaleable working URL for your application take hours if not days. Setting up something like Kubernetes is a huge task. This is where Google Cloud Run shines, you can get a working HTTPs URL for any of your containerized app in minutes.</p>

<p><a href="https://cloud.google.com/run/">Google Cloud Run</a> is serverless and fully managed by Google, you get super scale, billing by the second, HTTPs URL and your own domain mapping. If you want to run stateless containers Cloud run is hands down the easiest way to do it. In this post, I will detail how to get your Laravel 6 app working on Google cloud run with Continous Integration (CI).</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/00laravel6-on-gcr.jpg" title="Get Laravel 6 running on Google cloud run in minutes with CI" alt="Get Laravel 6 running on Google cloud run in minutes with CI"></p>

<!-- more -->


<h2>Prerequisites</h2>

<ul>
<li>You are familiar with PHP/Composer and aware of Laravel (if you&rsquo;ve landed here you are I suppose)</li>
<li>You know how to use Git from the CLI</li>
<li>Your code is hosted on GitHub for CI/CD and you are familiar with GitHub</li>
<li>Know a fair bit of docker, maybe even multi-stage build</li>
<li>Have a working Google cloud account (they give you <a href="https://cloud.google.com/free/">$300 credit</a> free for 1 yr, no reasons not to have an account)</li>
</ul>


<h2>Why is Cloud Run a great option for beginners</h2>

<p>For two reasons as mentioned below</p>

<ol>
<li>Learn about the best practices and software like docker and CI/CD</li>
<li>Getting the basics going is click a button, select 2 things wait for 5 mins you get a working HTTPs URL. Can it be any easier than this :)</li>
</ol>


<h2>Steps to deploy</h2>

<p>Below are the steps to set up and deploy Laravel 6 on Cloud Run:</p>

<h3>1. Clone Laravel or new Laravel project</h3>

<p>Start by cloning Laravel or using composer or the Laravel CLI as indicated in the official <a href="https://laravel.com/docs/5.8/installation">installation</a> guide. I am using composer to get the latest Laravel as below:</p>

<h4>Command</h4>

<p>I ran the following command to get the latest laravel:</p>

<pre><code class="bash">composer create-project --prefer-dist laravel/laravel laravel6-on-google-cloud-run
</code></pre>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/01install-laravel.jpg" title="Installing Laravel with composer" alt="Installing Laravel with composer"></p>

<h3>2. Test it locally first</h3>

<p>Then run <code>cd laravel6-on-google-cloud-run</code> then <code>php artisan serve</code> to see if it is working, for me it was fine when I went to <code>http://localhost:8000</code> on a web browser. I had PHP 7.2 installed locally.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/02running-laravel.jpg" title="Running Laravel locally" alt="Running Laravel locally"></p>

<h3>3. Create a new GitHub repo</h3>

<p>Create a new repository on Github like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/03github-repo.jpg" title="Creating a repo for Laravel on Github" alt="Creating a repo for Laravel on Github"></p>

<p>You can use any Git hosting provider, for this example I will be using <a href="https://github.com/features/actions">Github Actions</a> to run tests and Github is the most popular git hosting too.</p>

<h3>4. Add repo, push readme</h3>

<p>Now after you have the repo created, add it to your local Laravel copy and push the Readme file. To do this
run the following commands on your cli:</p>

<pre><code>git init
code . # I used VS code to change the readme
git add readme.md
git commit -m "Initial commit -- App Readme"
git remote add origin git@github.com:geshan/laravel6-on-google-cloud-run.git
git push -u origin master
</code></pre>

<h4>After running the above commands I had this on my github repo</h4>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/04initial-push.jpg" title="After the first push, repo looks like this" alt="After the first push, repo looks like this"></p>

<h3>5. Add full Laravel, open PR</h3>

<p>Now let&rsquo;s add the whole app as a PR to the Github repo by executing the following commands:</p>

<pre><code class="bash">git checkout -b laravel6-full-app
git add .gitignore
git add .
git commit -m "Add the whole Laravel 6 app"
git push origin laravel6-full-app
</code></pre>

<p>After that go and open a Pull Request (PR), on the repo like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/1">this</a> one. You might be thinking I am the only one working on this, why
do I need a PR? Well, it is always better to do things methodically even if it is just one person working on the project :).</p>

<p>After that merge your pull request.</p>

<h3>6. Setup tests with <a href="https://github.com/features/actions">GitHub actions</a></h3>

<p>Not some fun part, after you merged your PR now Github knows that this is a Laravel project. Click on  <code>Actions</code> tab on your repo page and you should be able to see something like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/05github-actions.jpg" title="Click Actions tab to view options" alt="Click Actions tab to view options"></p>

<p>Click the <code>Set up this workflow</code> under <code>Laravel</code> then on the next page click <code>Start commit</code> button on the top right. After that add a commit message like below and click <code>Commit new file</code>.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/06gh-actions-ci.jpg" title="Add Laravel tests action" alt="Add Laravel tests action"></p>

<p>There you go, you have your CI setup. Laravel default tests will run on each git push now. Wasn&rsquo;t that easy? Thank Github for this great intelligence. No more creating <code>.myCIname.yml</code> file anymore :).</p>

<h3>7. Add docker and docker-compose to run app locally</h3>

<p>Now let&rsquo;s add docker and docker-compose to run the app locally without PHP or artisan serve. We will need the container to run Laravel on Google Cloud Run too. This part is inspired by <a href="https://nsirap.com/posts/010-laravel-on-google-cloud-run/">Laravel on Google Cloud Run</a> post by Nicolas. If you want to learn more about <a href="https://www.docker.com/">Docker</a> and Laravel please refer to this <a href="https://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker/">post</a>.</p>

<p>Run the following commands first to get your master up to date as we added the <code>workflow</code> file from Github interface:</p>

<pre><code>git checkout master
git fetch
git pull --rebase origin master # as we added the workflow file from github interface
git checkout -b docker
</code></pre>

<p>Add a key to the <code>.env.example</code> file, copy it from <code>.env</code> file like below:</p>

<pre><code>APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:DJkdj8L5Di3rUkUOwmBFCrr5dsIYU/s7s+W52ClI4AA=
APP_DEBUG=true
APP_URL=http://localhost
</code></pre>

<p>As this is just a demo this is ok to do, for a real app always be careful with secrets.
For production-ready apps do turn of the debugging and other dev related things.</p>

<p>Add the following <code>Dockerfile</code> on the project root:</p>

<pre><code>FROM composer:1.9.0 as build
WORKDIR /app
COPY . /app
RUN composer global require hirak/prestissimo &amp;&amp; composer install

FROM php:7.3-apache-stretch
RUN docker-php-ext-install pdo pdo_mysql

EXPOSE 8080
COPY --from=build /app /var/www/
COPY docker/000-default.conf /etc/apache2/sites-available/000-default.conf
COPY .env.example /var/www/.env
RUN chmod 777 -R /var/www/storage/ &amp;&amp; \
    echo "Listen 8080" &gt;&gt; /etc/apache2/ports.conf &amp;&amp; \
    chown -R www-data:www-data /var/www/ &amp;&amp; \
    a2enmod rewrite
</code></pre>

<p>Then add the following file at <code>docker/000-default.conf</code></p>

<pre><code>&lt;VirtualHost *:8080&gt;

    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/public/

    &lt;Directory /var/www/&gt;
      AllowOverride All
      Require all granted
    &lt;/Directory&gt;

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

&lt;/VirtualHost&gt;
</code></pre>

<p>After that add the following <code>docker-compose.yml</code></p>

<pre><code>version: '3'
services:
  app:
    build:
      context: ./
    volumes:
      - .:/var/www
    ports:
      - "8080:8080"
    environment:
      - APP_ENV=local
</code></pre>

<h4>Boil down to main things</h4>

<p>If you try to understand everything here it might be overwhelming, let me boil down the main parts:</p>

<ol>
<li>We are using the official PHP Apache docker image to run Laravel, it has PHP version 7.3.</li>
<li>We are using multistage build to get the dependencies with Composer then copying them to the main docker image that has PHP 7.3 and Apache.</li>
<li>As Google Cloud Run requires the web-server to be listening to port <code>8080</code> we are using <code>000-default.conf</code> to configure this</li>
<li>To make things easy to run with single command <code>docker-compose up</code> we are using docker-compose.</li>
<li>Now as you have read this far, run <code>docker-compose up</code> on your root and then after everything runs go to <code>http://localhost:8080</code> to see that Laravel 6 is running locally on Docker. Below is my <code>docker-compose up</code> output towards the end:</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/07docker-compose-output.jpg" title="Docker compose running Laravel with PHP 7.3 and Apache" alt="Docker compose running Laravel with PHP 7.3 and Apache"></p>

<p>As Laravel is running fine with Docker, let&rsquo;s open a PR like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/2/files">this</a> one to add Docker to our project. I ran the following commands on the root of the project before opening the Pull Request (PR):</p>

<pre><code>git status
</code></pre>

<p>It should give you something like below:</p>

<pre><code>On branch docker
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    Dockerfile
    docker-compose.yml
    docker/

nothing added to commit but untracked files present (use "git add" to track)
</code></pre>

<p>Now run the following commands:</p>

<pre><code>git add .
git commit -m "Add docker and docker compose"
git push origin docker
</code></pre>

<p>As a bonus it will run the Laravel default test on the push, like you can see below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/08test-running-gh.jpg" title="On each push PHP unit test will run" alt="On each push PHP unit tests will run"></p>

<p>Only the owner of the repo has access to the <code>Actions</code> tab so other people don&rsquo;t necessarily need to know the results of your test builds :).</p>

<h3>8. Add deploy to <a href="https://github.com/GoogleCloudPlatform/cloud-run-button">Google Cloud button</a></h3>

<p>Now let&rsquo;s deploy this Laravel setup to Google Cloud Run the easy way. Given you have merged your PR from the <code>docker</code> branch. Let&rsquo;s run the following commands:</p>

<pre><code>git checkout master
git fetch
git pull --rebase origin master
git checkout -b cloud-run-button
</code></pre>

<p>Then add the following to your <code>readme.md</code> file:</p>

<pre><code>### Run on Google cloud run

[![Run on Google Cloud](https://storage.googleapis.com/cloudrun/button.svg)](https://console.cloud.google.com/cloudshell/editor?shellonly=true&amp;cloudshell_image=gcr.io/cloudrun/button&amp;cloudshell_git_repo=https://github.com/geshan/laravel6-on-google-cloud-run.git)
</code></pre>

<p>Be careful and replace the last part with your repo&rsquo;s <code>HTTPs</code> URL, for example, if your repo is at <code>https://github.com/ghaleroshan/laravel6-on-google-cloud-run</code> it will be <code>https://github.com/ghaleroshan/laravel6-on-google-cloud-run.git</code>, then commit and push. Your PR should look something like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/3/files">this</a> one.</p>

<h3>9. Deploy on Google Cloud Run</h3>

<p>After you merge your Pull Request (PR), then go to your repo page and click on the <code>Run on Google Cloud</code> button.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/09cloud-run-button.jpg" title="Click on the blue button to deploy the app" alt="Click on the blue button to deploy the app"></p>

<p>After that, given you are logged into your Google account and have Google cloud setup with 1 project, click &ldquo;Proceed&rdquo;. You might need to wait a bit, Then</p>

<ol>
<li>Choose the project &ndash; <code>Choose a project to deploy this application</code></li>
<li>Choose the region &ndash; <code>Choose a region to deploy this application</code>, I usually go with <code>us-central-1</code></li>
<li>Then wait for the container to be built and deployed, you can see my process below:</li>
</ol>


<p>If everything goes fine on your <code>Google Cloud Shell</code>, you will see HTTPs URL you can hit to see your
Laravel app running like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/10laravel-running-gcr.jpg" title="Hit the given URL to see its running" alt="Hit the given URL to see its running"></p>

<p>What just happened above is:</p>

<ol>
<li>After choosing the region, the script built a docker container image from the <code>Dockerfile</code> in the repo</li>
<li>Then it pushed the built image to <a href="https://cloud.google.com/container-registry/">Google Container Registry</a></li>
<li>After that using the <a href="https://cloud.google.com/sdk/gcloud/">gcloud</a> CLI it deployed the built image to Cloud Run, which gave back the URL.</li>
</ol>


<h3>10. Hurray, your app is working</h3>

<p>After you git the URL you should see your app working on Google Cloud Run like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/11laravel-url.jpg" title="Laravel Running on Google Cloud Run" alt="Laravel Running on Google Cloud Run"></p>

<p>If you want to deploy another version you can merge your PR to master and click the button again to deploy.</p>

<h2>More about Google Cloud Run</h2>

<p>The <a href="https://cloud.google.com/run/pricing">pricing</a> for Google Cloud Run is very generous. You can run any containerized app or web app on Google cloud run. I ran a pet project that got ~ 1 request per minute and I did not have to pay anything.</p>

<p>Behind the scenes, it is using <a href="https://cloud.google.com/knative/">Knative</a> and <a href="https://kubernetes.io/">Kubernetes</a>. It can also be run on your Kubernetes cluster but who would choose to manage a K8s cluster if you can just push and get scaleable serverless fully managed app :).</p>

<h2>TLDR</h2>

<p>To run Laravel 6 on Google Cloud Run quickly follow the steps below:</p>

<ol>
<li>Make sure you are logged into your <a href="https://console.cloud.google.com/">Google Cloud Account</a></li>
<li>Go to <a href="https://github.com/geshan/laravel6-on-google-cloud-run">https://github.com/geshan/laravel6-on-google-cloud-run</a></li>
<li>Click the &ldquo;Run On Google Cloud&rdquo; blue button</li>
<li>Select your project</li>
<li>Select your region</li>
<li>Wait and get the URL of your Laravel App as below, Enjoy!</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/10laravel-running-gcr.jpg" title="Hit the given URL to see its running" alt="Hit the given URL to see its running"></p>

<hr />

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/11laravel-url.jpg" title="Laravel Running on Google Cloud Run" alt="Laravel Running on Google Cloud Run"></p>

<h2>Conclusion</h2>

<p>There you go running a Laravel app on Google cloud run was pretty easy. You have even got test running on Github with Github actions. Hope it helps. To do a CI/CD approach you can check this <a href="https://medium.com/google-cloud/simplifying-continuous-deployment-to-cloud-run-with-cloud-build-including-custom-domain-setup-ssl-22d23bed5cd6">post</a>, it shows deployment using Cloud build. As the same container is running for local and production (Google Cloud Run) environment you don&rsquo;t need to learn a new framework to go Serverless.</p>

<blockquote><p>Any containerized web app can be run on Google Cloud Run, it is a great service.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[4 ways Docker changed the way software engineers work in past half decade]]></title>
    <link href="https://geshan.com.np/blog/2018/11/4-ways-docker-changed-the-way-software-engineers-work-in-past-half-decade/"/>
    <updated>2018-11-30T22:14:51+00:00</updated>
    <id>https://geshan.com.np/blog/2018/11/4-ways-docker-changed-the-way-software-engineers-work-in-past-half-decade</id>
    <content type="html"><![CDATA[<p>10 years back it was Git that transformed the way software engineers worked. Half a decade back it was <a href="https://www.docker.com/">Docker</a> that brought the container to the masses. Before Docker, container was like a sacred secret in companies like Google and Heroku. Docker is a software and a company too. It tried to build a broader ecosystem but <a href="https://kubernetes.io/">Kubernetes</a> stole the thunder along the way keeping <a href="https://docs.docker.com/engine/swarm/">swarm</a> at bay. This post is not about how some Docker tools are not popular. It is about how Docker has changed the way we work in the past 5 years.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" title="4 ways Docker changed the way software engineers work in past 5 years" alt="4 ways Docker changed the way software engineers work in past 5 years" data-echo="/images/4-ways-docker/docker-whale.jpg"></p>

<!-- more -->


<h2>TLDR;</h2>

<blockquote><p>With Docker, you ship the whole stack not only your code. Allocate minimum required resources to containers then scale them horizontally. With containers security generally already comes baked In. With Docker and Kubernetes you can get zero downtime and faster deployments leading to business profit.</p></blockquote>

<h2>Changed the ways</h2>

<p>If you want to go to the technical details of what is a container and why to use docker Google it :).</p>

<blockquote><p>Docker has also partially deprecated many of the configuration management tools.</p></blockquote>

<p>This post is about how Docker has changed the way we work after its release in March 2013. Below are some reasons that helped advance our way of working:</p>

<h3>Ship the whole stack, not just code</h3>

<p>With containers and Docker in specific, you always ship the whole stack in each version. The whole image gets rebuilt every time. It includes the precise OS+version, specific version of the language. It also has the dependencies like the framework and other libraries (versions depend on how you handle it). It also includes the code you have written and this results in a significant advantage. The advantage is, if it built correctly on your machine, it will potentially build on the server too. As soon as it runs it is the exact same environment on dev, staging, testing and even on production.</p>

<blockquote><p>It happens because you didn&rsquo;t shop only the code, you shipped your code + vendor code + specific language version + precise OS version too.</p></blockquote>

<h3>Allocate only needed resources to the application and scale horizontally</h3>

<p>With each Docker container, you can be specific about how much resources you want to allocate to that particular container. Using software like Kubernetes it becomes so much easier to scale your application. Under high load, the no. of containers can expand and with less load, it can shrink too. So with this mechanism, each container (or pod for Kubernetes) can be allocated the minimum resources and scaled horizontally as per need.</p>

<blockquote><p>For example, a simple Node JS app container/pod can run with like 128 MB memory and 0.25 CPU. As and when load increases run 5 pods in place of 2.</p></blockquote>

<p>This requires the application to be built with horizontal scalability in mind. That basically means storing no data on the file system. Treating containers like cattle, not pet helps scale horizontally. It also makes high availability of application an achievable task.</p>

<h3>Security is baked in</h3>

<p>Using a container, not virtual machine the attack surface is already decreased. Following container security best practices you can already improve your security measures. Of course, if you have holes in the application like SQL injection that is a different story. Still, with smaller and security-focused images like Alpine, it will be easier to get the basics right.</p>

<blockquote><p>Security is always about keeping the attack surface small. With containers and Docker closing more doors become easier.</p></blockquote>

<p>The container should have access to only what it needs. As the file system is temporary for containers it can be a security boon as well as a security auditing issue.</p>

<h3>Deploy faster with zero downtime</h3>

<p>Deploying Docker containers is always about shipping the whole stack. So the chances of one file not syncing or one server not getting the latest changes are not there. As a successful build of the image is always required to deploy it any problems will be found in the build process.</p>

<blockquote><p>With software like Kubernetes and Helm, orchestrating and deploying containers become straightforward. With High Availability (HA) in place using proper load balancing, deployments can be zero downtime.</p></blockquote>

<p>Easier and faster deployment equates to the ability to deploy smaller changes. Smaller changes done well can lead to a better response to market needs quickly. To sum up, use the right tools to deploy your containers in a way to use it for business advantage.</p>

<h2>Conclusion</h2>

<p>The past 5 years have seen rapid adoption of Docker. With tools like Kubernetes deploying and scaling applications has been much effortless than some years ago.</p>

<blockquote><p>Don&rsquo;t worship your virtual machines, use the resources it provides efficiently. Get on the Docker and containers train and reap its benefits.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why use docker? 3 reasons from a development perspective]]></title>
    <link href="https://geshan.com.np/blog/2018/10/why-use-docker-3-reasons-from-a-development-perspective/"/>
    <updated>2018-10-10T04:29:22+00:00</updated>
    <id>https://geshan.com.np/blog/2018/10/why-use-docker-3-reasons-from-a-development-perspective</id>
    <content type="html"><![CDATA[<p>Docker has been popular in the technology space in the past 5 years is an understatement. It has <a href="https://trends.google.com/trends/explore?date=2013-09-08%202018-10-08&amp;q=%2Fm%2F0wkcjgj">exploded</a> in usage and popularity in half a decade. Containers have taken us by storm. Newer applications without containerization feel like it is missing something. Docker has stood out to be the king in the container arena. This post details the reasons to use Docker for your development environment.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/why-docker/whale.jpg" title="Why use docker? 3 reasons from a development perspective" alt="Why use docker? 3 reasons from a development perspective"></p>

<!-- more -->


<h2>TLDR;</h2>

<blockquote><p>Docker is super useful for development environment because if it runs on your machine, it runs anywhere. It runs on your friend&rsquo;s machine, on staging and also on production. When a new team member starts, s/he runs 3 commands and the app(s) are running. The new team member can be productive from day 1. Finally, a new version of PHP or MYSQL is coming. You can test your app easily with Docker and make it run in the old version with no issues.</p></blockquote>

<h2>Docker Docker Docker</h2>

<p>You can <a href="https://runnable.com/docker/why-use-docker">read</a> all you want about Virtual Machines (VMs) vs Containers. And there is a list of reasons to use Docker in the <a href="https://www.airpair.com/docker/posts/8-proven-real-world-ways-to-use-docker">real-world</a>. This piece discusses why to use Docker for development. If you want to go hands read about using <a href="https://geshan.com.np/blog/2017/05/how-to-use-docker-compose-with-virtual-hosts-and-services-like-db-for-dev-environment/">docker and docker compose</a> for your development environment.</p>

<p>Docker has many advantages but the most important one is the container analogy. That you don&rsquo;t only ship your code but ship the whole OS and all related layers with each deployment in a standard way. It is a complete package containing the right version of OS, the desired version of the language, any external dependencies of your application and your application code. That too in a lightweight, isolated and resource controllable way. This is where docker blows away the VMs.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/why-docker/ship.jpg" title="Why use docker? 3 reasons from a development perspective" alt="Why use docker? 3 reasons from a development perspective"></p>

<h2>Reasons to use Docker for the development environment</h2>

<p>If you have read this far, now let&rsquo;s dive into the reasons you would want to use Docker for your development environment:</p>

<h3>1. Runs on my machine = runs anywhere</h3>

<p>If you have correctly dockerized your app and it runs without problems on your machine, 99% of the times it will run smoothly anywhere. By anywhere it means on your friend&rsquo;s machine, on the staging environment and production too. Given all of them have docker installed and configured correctly your app will run. Using docker also makes the application code cloud provider agnostic. Your application can potentially run on AWS or GCP or Azure without issues.</p>

<h3>2. New team member can be productive from day 1</h3>

<p>Think of this, a new team member joins then s/he spends more than a day to set up the machine with the right OS. Setup the language(s) used in the company add database(s) on top of it. 2-3 days is wasted on just getting the environment setup correctly. Enter docker + docker-compose, the new joiner sets up the OS. Installs docker then runs 3-5 commands, grabs some coffee and magic: your apps(s) are running. The new joiner can contribute with the working code on day 1. Think of all the cost a company can save with this approach. A streamlined docker implementation makes it a reality.</p>

<h3>3. Test app&rsquo;s compatibility with the newer version of language/database</h3>

<p>Picture this, a new version of the language you use just released. Like you were using PHP 5.6 and 7.0 has come out. You don&rsquo;t know how much work will be needed to make your application compatible with the new version of the language. Use docker here, you just need to run two different docker containers one running the current version and another running the newer version. You can even test the app side by side to measure performance. This can apply for any programming language.</p>

<p>The same technique can be used to say test MYSQL version 5.7 and 8.0. You might think there are tools like NVM (Node version manager) or RVM (Ruby version manager) but things like that don&rsquo;t exist for each language. Also, you can just use docker than overloading your local machine.</p>

<h2>Conclusion</h2>

<p>Docker is a boon to both software engineers and DevOps engineers. It makes releasing software much easier as the whole stack is shipped not only the code. Still, to move your production to Docker many things need to be considered. Things like container builder (for instance <a href="https://cloud.google.com/cloud-build/docs/">Google cloud build</a>), container orchestration (like <a href="https://kubernetes.io/">Kubernetes</a>). So before jumping to the container on staging/production be convinced of its benefits on the local development environment. I hope you exploit Docker to extract the most benefit out of it.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't just learn a new language/framework, implement it as a running open source project]]></title>
    <link href="https://geshan.com.np/blog/2018/10/dont-just-learn-a-new-language-slash-framework/"/>
    <updated>2018-10-08T04:27:26+00:00</updated>
    <id>https://geshan.com.np/blog/2018/10/dont-just-learn-a-new-language-slash-framework</id>
    <content type="html"><![CDATA[<p>“For the things we have to learn before we can do them, we learn by doing them.” ― Aristotle, The Nicomachean Ethics. Imagine you already read 3 books about cycling. Then someone gave you a cycle and asked to ride it, will you be able to ride it? The simple answer is &ldquo;No&rdquo;. It is not about how much have you read about cycling or how many videos did you watch about it. It is about getting on a cycle, balancing on it, learning the feet, hands and eye co-ordination. Same goes for learning a new tech skill, a new language or framework.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/language-framework-learn/cycle.jpg" title="Dont just learn a new language framework, implement it as a running open source project" alt="Dont just learn a new language framework, implement it as a running open source project"></p>

<!-- more -->


<p>Now if you think how will I do this new project I don&rsquo;t even know language &lsquo;X&rsquo; or framework &lsquo;Y&rsquo; stop complaining. Maybe you are a new starter in tech or coding but you need to know how to learn new things. The best way to learn something new is by doing it.</p>

<blockquote><p>This post will focus on getting some common things right. It will help you get from I want to learn &lsquo;X&rsquo; to I have a project running in &lsquo;X&rsquo;, so follow on.</p></blockquote>

<p>If you are convinced about doing a project to learn something new, open source it. Github is the de facto service to host your open source projects. Then you can leverage lots of services for free. This post will be equally useful for coding new starters as well as experienced software engineers.</p>

<h2>TLDR;</h2>

<blockquote><p>Write a project to learn that language/framework, open source it then leverage services for free. Don&rsquo;t just watch courses, read the docs and then find solutions. Learn by doing. Use git and implement docker in your project. Code correctly add a code quality check service to be aware of the best practices, deploy your project to get a working URL for it.</p></blockquote>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/language-framework-learn/lang-framework-learn.jpg" title="Dont just learn a new language framework, implement it as a running open source project" alt="Dont just learn a new language framework, implement it as a running open source project"></p>

<h2>Don&rsquo;t just watch courses, read the docs and find solutions</h2>

<p>Nowadays, there are a plethora of choices to learn new things. Still, video courses are one of the most popular media. You can learn something new on <a href="https://www.udemy.com">Udemy</a>, <a href="https://www.pluralsight.com/">Pluralsight</a> or even <a href="https://youtube.com">Youtube</a>.</p>

<blockquote><p>Until you learn by doing, watching the videos is only going to help to a certain level. It is better for you to go through the official documentation.</p></blockquote>

<p>For instance, reading the React JS docs is better than only going through a React JS course. You find out the creators&#8217; perspective. The reason behind creating another Javascript framework/library helping you find proper solutions.</p>

<h2>Learn Git to collaborate</h2>

<p>&ldquo;No man is an island&rdquo;, especially in tech you generally don&rsquo;t work alone. You are part of a team. So even when learning something new try to find someone who you can collaborate with.</p>

<blockquote><p>Git is immensely <a href="https://trends.google.com/trends/explore?q=git,svn,mercurial,bazaar">popular</a> compared to any of its competition. It is beneficial when there is more than 1 person writing code for a project.</p></blockquote>

<p>You should learn git by doing, check the Github <a href="https://try.github.io/">tutorial</a>. I would highly recommend the learn by doing section. After you push it to Github anyone can potentially contribute to it.</p>

<h2>Implement docker, get over works on my machine syndrome</h2>

<p>In 2018, if you want to make your application more accessible, use <a href="https://www.docker.com/">Docker</a>. This will also help a lot in increasing contribution for your open source project. Running your project locally with docker compose will be like executing 2 commands.</p>

<blockquote><p>Docker has many advantages. For a beginner, it is a way to make sure your app runs the same way on your machine, your friend&rsquo;s machine.</p></blockquote>

<p>It will also be the same on the server you deploy your app to. As long as it runs on Docker well, you can rest assured it will run without issues on any environment.</p>

<h2>Add code quality check</h2>

<p>Just making it work should not be your priority. Writing quality should also be in your priority. Add code quality checks for the open source project you created for learning. Depending on the language/framework you could choose any service.</p>

<blockquote><p>I would highly recommend <a href="https://codeclimate.com/quality/">Code Climate</a>. Code Climate supports a wide array of languages from Javascript to PHP and from Java/Kotlin to Swift for mobile developers.</p></blockquote>

<p>With the new <a href="https://codeclimate.com/browser-extension/">browser plugin</a>, you get insights about your code in a Github pull request screen. You just connect it once to your Github repo and start seeing your code quality report. You can then better your code quality too. You can have a look at this <a href="https://codeclimate.com/github/geshan/currency-api/src/exchangeRates.js/source">example</a>.</p>

<h2>Deploy your project</h2>

<p>Now you are writing a new project to learn your favorite &lsquo;X&rsquo; or &lsquo;Y&rsquo;. You have written some parts of it, you are collaborating with Git and have the code open source on Github. You have Docker in place and code quality checks run on each push, great! But you can&rsquo;t show it to your friend who is living in a different city/country right? Wrong!</p>

<p>You can use different services to deploy your web application. With a URL you can show it to your friend, a recruiter or anyone who knows the URL.</p>

<blockquote><p>You can deploy it for free to services like <a href="https://www.heroku.com">Heroku</a> or <a href="https://zeit.co/now">Zeit Now</a>. If you have Dockerized your open source app I would recommend Zeit Now.</p></blockquote>

<p>With the recent <a href="https://zeit.co/github">Github integration</a>, Zeit Now will give a new URL to each pull request. This makes testing a breeze. You can check an example on a demo <a href="https://github.com/geshan/currency-api/pull/9">currency converter API</a> app I wrote.</p>

<h2>Conclusion</h2>

<blockquote><p>To conclude, learning by doing is the best way to learn a new thing. Your aim should be to not only make it work but do it following the best practices. That is where code quality comes into play. If you can add automated tests and continuous integration it will be icing on the cake for a starter. Wish you all the best for learning by doing!</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to use docker compose with virtual hosts and shared services (like db) for dev environment]]></title>
    <link href="https://geshan.com.np/blog/2017/05/how-to-use-docker-compose-with-virtual-hosts-and-services-like-db-for-dev-environment/"/>
    <updated>2017-05-24T14:53:04+00:00</updated>
    <id>https://geshan.com.np/blog/2017/05/how-to-use-docker-compose-with-virtual-hosts-and-services-like-db-for-dev-environment</id>
    <content type="html"><![CDATA[<p>Docker as been immensely popular in the past years. If you are not using docker at least in your dev environment in 2017.
You are surely missing out on some great advantages. Your new software engineer should start writing production-ready code
in a matter of hours not days. All thanks to docker.  Along the same lines, this post will cover how you can set up
docker for your dev environment with least friction and maximum productivity. It is an opinionated post. We migrated to this <code>external_links</code>
<a href="https://docs.docker.com/compose/compose-file/#externallinks">approach</a> so that we could run multiple projects/microservices that use the same db/services shared among them.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/docker-compose-vhost/docker-compose-vhost.jpg" title="Docker compose with vhost and shared services" alt="Docker compose with vhost and shared services"></p>

<!-- more -->


<h2>Context</h2>

<ul>
<li>This tutorial is generally agnostic of docker and docker-compose versions (I am using docker compose 1 syntax). I assume you have docker and docker-compose installed and know about them.</li>
<li>It uses external images like Nginx proxy for virtual host per project. Mysql db as shared external service. It could also have been mongo or redis or even rabbit mq. The main point is to use it as <code>external_link</code> in the docker compose file, so that it can be shared among projects.</li>
<li>It uses a demo app which emulates the page visit/hit counter popular decades back with a <a href="https://github.com/geshan/counter/blob/master/index.js">~30 liner Nodejs app</a> and Mysql db.</li>
<li>I would like to keep the description as concise as possible and in points to make it simple and clear. You should read the code of <a href="https://github.com/geshan/counter">sample counter project</a> and sample mysql container&rsquo;s <a href="https://github.com/geshan/sample-mysql/blob/master/docker-compose.yml">docker-compose.yml</a> well.</li>
<li>The goal is to grasp the concepts well and apply it to your current project. For example, you could start with replacing your local mysql install with a docker container.</li>
</ul>


<h2>Problems to solve</h2>

<ol>
<li>After I use docker and docker compose, the web server (nginx/apache etc) of project A takes up port 80 and I can&rsquo;t run project B on port 80 or have a virtual host for both projects.</li>
<li>When I use my db (mysql/postgres) as a service in my docker compose for project A, It is cumbersome to use the same db for another project as its coupled with project A.</li>
<li>I just want to run my mysql database, import some data and run some queries. I don&rsquo;t want to run my app for now.</li>
</ol>


<h2>Solution goals</h2>

<ol>
<li>To make services like db etc independent of projects and shared among projects similar to having a local install of mysql with multiple databases.</li>
<li>Multiple projects should be able to run in parallel and each of them will have their own virtual host for easy accessibility.</li>
</ol>


<h2>Steps</h2>

<ol>
<li>Run the Nginx proxy to enable virtual hosts with <code>$ docker run -d -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock:ro jwilder/nginx-proxy</code></li>
<li>Add <code>127.0.0.1 counter.local.dev</code> to your hosts file (on unix based system it is <code>/etc/hosts</code> file)</li>
<li>Create an empty folder db in your home (<code>~/db</code>), to save your mysql data</li>
<li>Clone mysql repo from <a href="https://github.com/geshan/sample-mysql">here</a> maybe at <code>~/projects/mysql</code></li>
<li>In <code>~/projects/mysql</code> run docker-compose up to run mysql, it will create <a href="https://github.com/geshan/sample-mysql/blob/master/init-dump/counter.sql">counter db, counts table with one row</a>.</li>
<li>Clone the sample counter app from <a href="https://github.com/geshan/counter">here</a> to maybe <code>~/projects/counter</code>.</li>
<li>In <code>~/projects/counter</code> run <code>docker-compose up</code></li>
<li>Then go to <code>http://counter.local.dev</code> on your browser you should see <code>Page visited 1 times</code>, refresh it, it should say <code>Page visited 2 times</code></li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/docker-compose-vhost/page-visited.png" title="All working you should see this" alt="All working you should see this"></p>

<p>Virtual host has been possible in above setup as we ran the nginx proxy and configured <code>VIRTUAL_HOST</code> and <code>VIRTUAL_PORT</code> parameters correctly
in the docker-compose.yml of the sample counter project. Mysql was already running before the project even started to run and it was <code>external_links</code>,
the IP of the mysql container was automatically added to the <code>/etc/hosts</code> of the counter project container which enabled us to use the host for mysql db
as <a href="https://github.com/geshan/counter/blob/master/index.js#L4">mysql</a> in the connection config we passed to the mysql library.</p>

<p>Steps for running dependent services like nginx proxy, mysql can surely be automated for speed and efficiency.</p>

<h2>Takeaways</h2>

<ol>
<li>You can plan a step by step migration like first get your db/queue migrated from local install to docker then the app.</li>
<li>Use <code>external_links</code> for all the services like db/queue/redis/solr anything that needs to be shared among projects.</li>
<li>Use <a href="https://github.com/jwilder/nginx-proxy">nginx proxy</a> to enable virtual host per project with two simple env variables <code>VIRTUAL_HOST</code> and <code>VIRTUAL_PORT</code> in the project&rsquo;s <a href="https://github.com/geshan/counter/blob/master/docker-compose.yml#L8-L9">docker-compose</a> file. <code>VIRTUAL_PORT</code> is 8080 because application is <a href="https://github.com/geshan/counter/blob/master/index.js#L27">running</a> on port 8080 and same port is exposed from the <a href="https://github.com/geshan/counter/blob/master/Dockerfile#L10">dockerfile</a>.</li>
<li>Run all your dependencies before hand and then run <code>docker-compose up</code> on your project(s). Dependencies can be run with <code>docker-compose up -d</code> to put it in the background. You can use <code>docker-compose -f logs</code> to follow logs and check if the service is running fine.</li>
<li>In this way, you can run multiple projects sharing the same db instance and each project can have its own virtual host.</li>
</ol>


<blockquote><p>Hope you found this helpful. For more clarity, please read the <a href="https://github.com/geshan/counter/blob/master/Dockerfile">Dockerfile</a>, <a href="https://github.com/geshan/counter/blob/master/docker-compose.yml">docker-compose.yml</a> and <a href="https://github.com/geshan/counter/blob/master/index.js">index.js</a> of the sample counter project thoroughly.</p></blockquote>
]]></content>
  </entry>
  
</feed>
