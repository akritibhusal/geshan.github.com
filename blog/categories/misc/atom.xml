<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: misc | Geshan's Blog]]></title>
  <link href="https://geshan.com.np/blog/categories/misc/atom.xml" rel="self"/>
  <link href="https://geshan.com.np/"/>
  <updated>2019-11-03T04:32:31+00:00</updated>
  <id>https://geshan.com.np/</id>
  <author>
    <name><![CDATA[Geshan Manandhar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to run Symfony on Google Cloud Run with the demo app [Step-by-Step Guide]]]></title>
    <link href="https://geshan.com.np/blog/2019/11/how-to-run-symfony-on-google-cloud-run-with-the-demo-app-step-by-step-guide/"/>
    <updated>2019-11-03T14:22:00+00:00</updated>
    <id>https://geshan.com.np/blog/2019/11/how-to-run-symfony-on-google-cloud-run-with-the-demo-app-step-by-step-guide</id>
    <content type="html"><![CDATA[<p>Symfony is without doubts one of the most <a href="https://raygun.com/blog/top-php-frameworks/">popular</a> PHP frameworks. It has amazing flexibility and is written in an applaudable modular fashion. Some Symfony components even <a href="https://symfony.com/projects/laravel">power</a> other prominent frameworks like Laravel. Running Symfony is a bit tricky at times, especially the <a href="https://symfony.com/doc/current/setup/file_permissions.html">permissions</a> of the cache and logs folder, this blog post demystifies running the Symfony <a href="https://github.com/symfony/demo">Demo App</a> in a docker container and hosting it serverless on <a href="https://cloud.google.com/run/">Google Cloud Run</a>.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/symfony-on-google-cloud-run/00symfony-on-gcr.jpg" title="Get Symfony running on Google Cloud Run with the demo app" alt="Get Symfony running on Google Cloud Run with the demo app"></p>

<!-- more -->


<h2>Prerequisites</h2>

<ol>
<li>You have done at least one project with Symfony (of course you are comfortable with PHP and composer)</li>
<li>You have a good working knowledge of git and Github</li>
<li>Know a fair bit of <a href="https://geshan.com.np/blog/categories/docker/">docker</a>, maybe even multi-stage build</li>
<li>Have a working Google cloud account (they give you <a href="https://cloud.google.com/free/">$300 credit</a> free for 1 yr, no reasons not to have an account)</li>
</ol>


<p>This post is not going to be a detailed one like the last one about <a href="https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci/">Laravel on Google Cloud Run</a>. If you are fairly new Git or Docker, please do read the above-mentioned post thoroughly.</p>

<h2>Steps</h2>

<p>Before going to the steps, the repo is hosted on my <a href="https://github.com/geshan/symfony-demo-google-cloud-run">Github</a> and it is open-source of course. It might look insanely easy but we will go through some details after the steps. So let’s get started now:</p>

<h3>1. Go to the repo</h3>

<p>Navigate to the open-source <a href="https://github.com/geshan/symfony-demo-google-cloud-run">Github</a> repo. That is a very easy step, isn’t it? :)</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/symfony-on-google-cloud-run/01github-repo.jpg" title="Github repo with Symfony demo app dockerized and ready for Google Cloud Run" alt="Github repo with Symfony demo app dockerized and ready for Google Cloud Run"></p>

<h3>2. Click on the Google Cloud button</h3>

<p>Then click on the <code>Run on Google Cloud</code> blue button, as shown below: 02google-cloud-button</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/symfony-on-google-cloud-run/02google-cloud-button.jpg" title="Just click the Google Cloud button and see it roll" alt="Just click the Google Cloud button and see it roll"></p>

<h3>3. Choose correct settings on Google cloud CLI</h3>

<p>After that, given you are logged into your Google account and have Google cloud setup with 1 or more projects, click <code>Proceed</code>. You might need to wait a bit, after that</p>

<ol>
<li>Choose the project – <code>Choose a project to deploy this application</code></li>
<li>Choose the region – <code>Choose a region to deploy this application</code>, I usually choose <code>us-central-1</code></li>
</ol>


<p>Then wait for the container to be built and deployed, you can see my process below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/symfony-on-google-cloud-run/03deploy-symfony.jpg" title="Steps to deploy Symfony on Google Cloud Run" alt="Steps to deploy Symfony on Google Cloud Run"></p>

<p>If everything goes fine on your Google Cloud Shell, you will see HTTPs URL you can go to in order to see your Symfony demo app running like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/symfony-on-google-cloud-run/04symfony-running.jpg" title="Symfony running on Google Cloud Run" alt="Symfony running on Google Cloud Run"></p>

<p>One issue with this setup is that data will not be saved if you click around and add new posts. This happens because the data is saved in the SQLite file, as it is not persisted new containers get the old file and you get the same data pushed in the repo.</p>

<h2>So what just happened?</h2>

<p>There are some things you need to consider for this automagic deployment of the Symfony App. Let’s look at what just happened above:</p>

<ol>
<li>The Symfony Demo app has been dockerized, have a look at this <a href="https://github.com/geshan/symfony-demo-google-cloud-run/blob/master/Dockerfile">Dockerfile</a> and the <a href="https://github.com/geshan/symfony-demo-google-cloud-run/blob/master/docker/000-default.conf">Apache config</a> too. The Dockerfile uses multistage build, on stage to install dependencies with composer and another one with Apache to run the application.</li>
<li>If you want to run it locally, just run <code>docker-compose up</code> then go to <code>http://localhost:8080</code>. <a href="https://cloud.google.com/run/docs/reference/container-contract">8080</a> is the required port needed for Google Cloud Run.</li>
<li>Thanks to the <a href="https://cloud.google.com/blog/products/serverless/introducing-cloud-run-button-click-to-deploy-your-git-repos-to-google-cloud">Google Cloud Run button</a> and the Cloud Shell script that does the automagic deployment.</li>
</ol>


<p>To make the most out of this tutorial, you can fork the <a href="https://github.com/geshan/symfony-demo-google-cloud-run">repo</a>, add your own button then explore more with it.</p>

<h2>Conclusion</h2>

<p>Running Symfony entails some tricky configuration :) so the Dockerized version is a breeze to run. I really believe that Google Cloud Run is a superior product if you know how to dockerize your web app and run it on port 8080 you can get amazing scalability with unparallel ease to make it run.</p>

<blockquote><p>I would recommend Cloud Run for any pet project or even production application.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Laracon AU 2019 overall a good experience]]></title>
    <link href="https://geshan.com.np/blog/2019/11/laracon-au-2019-overall-a-good-experience/"/>
    <updated>2019-11-01T09:01:15+00:00</updated>
    <id>https://geshan.com.np/blog/2019/11/laracon-au-2019-overall-a-good-experience</id>
    <content type="html"><![CDATA[<p>This is my second Laracon, the first one was <a href="https://geshan.com.np/blog/2016/08/number-laraconeu-2016-was-a-great-experience-overall/">Laracon EU 2016</a> which was one of the best conferences I have ever attended and spoken at. This blog post is a rundown of the talks of the first day of Laracon AU 2019 with slides from my talk, carry on reading…</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-au-2019/01-laracon-au-2019.jpg" title="Laracon AU 2019 stage" alt="Laracon AU 2019 stage"></p>

<!-- more -->


<h2>Day 1</h2>

<p>This is the second <a href="https://laracon.com.au/">Laracon</a> in Australia, the first one was in 2018. There were just over 200 people who attended the first day. The speaker line up looked pretty interesting with more than a couple of first-time conference speakers. TBH, no one seemed like they were taking the conference stage for the first time</p>

<h2>Talks were great</h2>

<p>The day was started by <a href="https://freek.dev/">Freek</a>, it was great meeting him after Laracon EU 2016. His talk was titled “A way to structure a large Laravel app” which is very good. The pointers on using typescript and creating a domain (kinda sub-apps) inside your Laravel were the highlights for me.</p>

<p>Then <a href="https://twitter.com/michael_timbs">Michael Tims</a> took on the stage to show how to test fronted Javascript Apps. The highlight for me was “Contract testing” in this talk as I was familiar with the regular forms of testing like unit, integration and even mutation testing. After him, <a href="https://blog.maxsnow.me/">Max Snow</a> showed us his Laravel API boilerplate and how it makes creating APIs on Laravel easy. Then it was me on stage and details about my talk “Are logs a software engineer’s best friend? Yes &ndash; follow these best practices” are below.</p>

<p>After lunch, <a href="https://jessarcher.com/">Jess Archer</a> spread her knowledge of SPAs, the highlight for me was using JWT token in cookies. As I have done it in the past it was easier for me to relate to the concept. Then <a href="https://samgreenwood.me/">Sam</a> took the stage to show us the need for strict types and tools in PHP to do it. I liked the multiple tools he mentioned like <a href="http://psalm.dev">Psalm</a>. After him, <a href="https://jessbudd.com">Jess Budd</a> showed us how to write semantic HTML to build apps accessible with screen readers. The main takeaway for me here was semantic HTML not only improves accessibility but also add more SEO juice to your website.</p>

<p>After the break, <a href="https://amyskapers.tech/">Amy</a> took on the stage to show us the magic of CSS grids. The main highlight for me was it helped me demystify the seemingly magical CSS grids. Last but not least was <a href="https://jasonmccreary.me/">JMac</a> (creater of Laravel <a href="https://laravelshift.com/">Shift</a>) giving us important pointers to “Creating maintainable Laravel applications”. He had 10 points to do so. My main takeaway was “grok the framework” if I was writing Laravel every day that is something I would remember and follow :)</p>

<p>You can follow all the tweets/images at <a href="https://twitter.com/search?q=%23laraconau">#laraconau</a> on twitter. Special thanks to <a href="https://twitter.com/shanesmithau">Shane Smith</a> for his amazing threads on twitter. I don’t know how he is tweeting, listening and taking pictures at the same time :).</p>

<h2>My talk</h2>

<p>I think my talk went pretty well too. There was no time or provision to ask a question which is Ok. Some people came in later to ask their queries about logging and how to get started. I consider that the talk was warmly received by the audience with some laughs and a lot of attention.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-au-2019/02-laracon-au-2019.jpg" title="My talk about Logging at Laracon AU 2019" alt="My talk about Logging at Laracon AU 2019"></p>

<h2>Slides</h2>

<p>Below are the slides from my talk:</p>

<script async class="speakerdeck-embed" data-id="26f9b284425c4048a8aa587e155636ce" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


<p>The slides are on <a href="https://www.slideshare.net/geshan/are-logs-a-software-engineers-best-friend-yes-follow-these-best-practices">slide share</a> too.</p>

<h2>Day 2</h2>

<p>Today is day 2 and let&rsquo;s see how it goes. <a href="https://twitter.com/marcusamoore">Marcus</a> is going to start the day.</p>

<h2>Conclusion</h2>

<p>Day 1 was good overall. One thing I noticed was the number of female attendees was quite low. This is something the organizers can work on else the venue, organization of the speakers and attendees was commendable. Thanks to <a href="https://twitter.com/michaeldyrynda">Michael</a> and the team for putting up such a great tech conference in Sydney bringing together like-minded technologists under the same roof. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set up Laravel 6 on Google Cloud Run step by step with Continuous Integration (CI)]]></title>
    <link href="https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci/"/>
    <updated>2019-10-21T08:03:29+00:00</updated>
    <id>https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci</id>
    <content type="html"><![CDATA[<p>Laravel has <a href="https://trends.google.com/trends/explore?date=2014-10-22%202019-10-21&amp;q=laravel,symfony">soared</a> in popularity in the last few years. The Laravel community even says that Laravel has made writing PHP enjoyable than a pain. Laravel 6 has some interesting new <a href="https://laracasts.com/series/whats-new-in-laravel-6">features</a>. Getting a super scaleable working URL for your application take hours if not days. Setting up something like Kubernetes is a huge task. This is where Google Cloud Run shines, you can get a working HTTPs URL for any of your containerized app in minutes.</p>

<p><a href="https://cloud.google.com/run/">Google Cloud Run</a> is serverless and fully managed by Google, you get super scale, billing by the second, HTTPs URL and your own domain mapping. If you want to run stateless containers Cloud run is hands down the easiest way to do it. In this post, I will detail how to get your Laravel 6 app working on Google cloud run with Continous Integration (CI).</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/00laravel6-on-gcr.jpg" title="Get Laravel 6 running on Google cloud run in minutes with CI" alt="Get Laravel 6 running on Google cloud run in minutes with CI"></p>

<!-- more -->


<h2>Prerequisites</h2>

<ul>
<li>You are familiar with PHP/Composer and aware of Laravel (if you&rsquo;ve landed here you are I suppose)</li>
<li>You know how to use Git from the CLI</li>
<li>Your code is hosted on GitHub for CI/CD and you are familiar with GitHub</li>
<li>Know a fair bit of docker, maybe even multi-stage build</li>
<li>Have a working Google cloud account (they give you <a href="https://cloud.google.com/free/">$300 credit</a> free for 1 yr, no reasons not to have an account)</li>
</ul>


<h2>Why is Cloud Run a great option for beginners</h2>

<p>For two reasons as mentioned below</p>

<ol>
<li>Learn about the best practices and software like docker and CI/CD</li>
<li>Getting the basics going is click a button, select 2 things wait for 5 mins you get a working HTTPs URL. Can it be any easier than this :)</li>
</ol>


<h2>Steps to deploy</h2>

<p>Below are the steps to set up and deploy Laravel 6 on Cloud Run:</p>

<h3>1. Clone Laravel or new Laravel project</h3>

<p>Start by cloning Laravel or using composer or the Laravel CLI as indicated in the official <a href="https://laravel.com/docs/5.8/installation">installation</a> guide. I am using composer to get the latest Laravel as below:</p>

<h4>Command</h4>

<p>I ran the following command to get the latest laravel:</p>

<pre><code class="bash">composer create-project --prefer-dist laravel/laravel laravel6-on-google-cloud-run
</code></pre>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/01install-laravel.jpg" title="Installing Laravel with composer" alt="Installing Laravel with composer"></p>

<h3>2. Test it locally first</h3>

<p>Then run <code>cd laravel6-on-google-cloud-run</code> then <code>php artisan serve</code> to see if it is working, for me it was fine when I went to <code>http://localhost:8000</code> on a web browser. I had PHP 7.2 installed locally.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/02running-laravel.jpg" title="Running Laravel locally" alt="Running Laravel locally"></p>

<h3>3. Create a new GitHub repo</h3>

<p>Create a new repository on Github like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/03github-repo.jpg" title="Creating a repo for Laravel on Github" alt="Creating a repo for Laravel on Github"></p>

<p>You can use any Git hosting provider, for this example I will be using <a href="https://github.com/features/actions">Github Actions</a> to run tests and Github is the most popular git hosting too.</p>

<h3>4. Add repo, push readme</h3>

<p>Now after you have the repo created, add it to your local Laravel copy and push the Readme file. To do this
run the following commands on your cli:</p>

<pre><code>git init
code . # I used VS code to change the readme
git add readme.md
git commit -m "Initial commit -- App Readme"
git remote add origin git@github.com:geshan/laravel6-on-google-cloud-run.git
git push -u origin master
</code></pre>

<h4>After running the above commands I had this on my github repo</h4>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/04initial-push.jpg" title="After the first push, repo looks like this" alt="After the first push, repo looks like this"></p>

<h3>5. Add full Laravel, open PR</h3>

<p>Now let&rsquo;s add the whole app as a PR to the Github repo by executing the following commands:</p>

<pre><code class="bash">git checkout -b laravel6-full-app
git add .gitignore
git add .
git commit -m "Add the whole Laravel 6 app"
git push origin laravel6-full-app
</code></pre>

<p>After that go and open a Pull Request (PR), on the repo like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/1">this</a> one. You might be thinking I am the only one working on this, why
do I need a PR? Well, it is always better to do things methodically even if it is just one person working on the project :).</p>

<p>After that merge your pull request.</p>

<h3>6. Setup tests with <a href="https://github.com/features/actions">GitHub actions</a></h3>

<p>Not some fun part, after you merged your PR now Github knows that this is a Laravel project. Click on  <code>Actions</code> tab on your repo page and you should be able to see something like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/05github-actions.jpg" title="Click Actions tab to view options" alt="Click Actions tab to view options"></p>

<p>Click the <code>Set up this workflow</code> under <code>Laravel</code> then on the next page click <code>Start commit</code> button on the top right. After that add a commit message like below and click <code>Commit new file</code>.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/06gh-actions-ci.jpg" title="Add Laravel tests action" alt="Add Laravel tests action"></p>

<p>There you go, you have your CI setup. Laravel default tests will run on each git push now. Wasn&rsquo;t that easy? Thank Github for this great intelligence. No more creating <code>.myCIname.yml</code> file anymore :).</p>

<h3>7. Add docker and docker-compose to run app locally</h3>

<p>Now let&rsquo;s add docker and docker-compose to run the app locally without PHP or artisan serve. We will need the container to run Laravel on Google Cloud Run too. This part is inspired by <a href="https://nsirap.com/posts/010-laravel-on-google-cloud-run/">Laravel on Google Cloud Run</a> post by Nicolas. If you want to learn more about <a href="https://www.docker.com/">Docker</a> and Laravel please refer to this <a href="https://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker/">post</a>.</p>

<p>Run the following commands first to get your master up to date as we added the <code>workflow</code> file from Github interface:</p>

<pre><code>git checkout master
git fetch
git pull --rebase origin master # as we added the workflow file from github interface
git checkout -b docker
</code></pre>

<p>Add a key to the <code>.env.example</code> file, copy it from <code>.env</code> file like below:</p>

<pre><code>APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:DJkdj8L5Di3rUkUOwmBFCrr5dsIYU/s7s+W52ClI4AA=
APP_DEBUG=true
APP_URL=http://localhost
</code></pre>

<p>As this is just a demo this is ok to do, for a real app always be careful with secrets.
For production-ready apps do turn of the debugging and other dev related things.</p>

<p>Add the following <code>Dockerfile</code> on the project root:</p>

<pre><code>FROM composer:1.9.0 as build
WORKDIR /app
COPY . /app
RUN composer global require hirak/prestissimo &amp;&amp; composer install

FROM php:7.3-apache-stretch
RUN docker-php-ext-install pdo pdo_mysql

EXPOSE 8080
COPY --from=build /app /var/www/
COPY docker/000-default.conf /etc/apache2/sites-available/000-default.conf
COPY .env.example /var/www/.env
RUN chmod 777 -R /var/www/storage/ &amp;&amp; \
    echo "Listen 8080" &gt;&gt; /etc/apache2/ports.conf &amp;&amp; \
    chown -R www-data:www-data /var/www/ &amp;&amp; \
    a2enmod rewrite
</code></pre>

<p>Then add the following file at <code>docker/000-default.conf</code></p>

<pre><code>&lt;VirtualHost *:8080&gt;

    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/public/

    &lt;Directory /var/www/&gt;
      AllowOverride All
      Require all granted
    &lt;/Directory&gt;

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

&lt;/VirtualHost&gt;
</code></pre>

<p>After that add the following <code>docker-compose.yml</code></p>

<pre><code>version: '3'
services:
  app:
    build:
      context: ./
    volumes:
      - .:/var/www
    ports:
      - "8080:8080"
    environment:
      - APP_ENV=local
</code></pre>

<h4>Boil down to main things</h4>

<p>If you try to understand everything here it might be overwhelming, let me boil down the main parts:</p>

<ol>
<li>We are using the official PHP Apache docker image to run Laravel, it has PHP version 7.3.</li>
<li>We are using multistage build to get the dependencies with Composer then copying them to the main docker image that has PHP 7.3 and Apache.</li>
<li>As Google Cloud Run requires the web-server to be listening to port <code>8080</code> we are using <code>000-default.conf</code> to configure this</li>
<li>To make things easy to run with single command <code>docker-compose up</code> we are using docker-compose.</li>
<li>Now as you have read this far, run <code>docker-compose up</code> on your root and then after everything runs go to <code>http://localhost:8080</code> to see that Laravel 6 is running locally on Docker. Below is my <code>docker-compose up</code> output towards the end:</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/07docker-compose-output.jpg" title="Docker compose running Laravel with PHP 7.3 and Apache" alt="Docker compose running Laravel with PHP 7.3 and Apache"></p>

<p>As Laravel is running fine with Docker, let&rsquo;s open a PR like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/2/files">this</a> one to add Docker to our project. I ran the following commands on the root of the project before opening the Pull Request (PR):</p>

<pre><code>git status
</code></pre>

<p>It should give you something like below:</p>

<pre><code>On branch docker
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    Dockerfile
    docker-compose.yml
    docker/

nothing added to commit but untracked files present (use "git add" to track)
</code></pre>

<p>Now run the following commands:</p>

<pre><code>git add .
git commit -m "Add docker and docker compose"
git push origin docker
</code></pre>

<p>As a bonus it will run the Laravel default test on the push, like you can see below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/08test-running-gh.jpg" title="On each push PHP unit test will run" alt="On each push PHP unit tests will run"></p>

<p>Only the owner of the repo has access to the <code>Actions</code> tab so other people don&rsquo;t necessarily need to know the results of your test builds :).</p>

<h3>8. Add deploy to <a href="https://github.com/GoogleCloudPlatform/cloud-run-button">Google Cloud button</a></h3>

<p>Now let&rsquo;s deploy this Laravel setup to Google Cloud Run the easy way. Given you have merged your PR from the <code>docker</code> branch. Let&rsquo;s run the following commands:</p>

<pre><code>git checkout master
git fetch
git pull --rebase origin master
git checkout -b cloud-run-button
</code></pre>

<p>Then add the following to your <code>readme.md</code> file:</p>

<pre><code>### Run on Google cloud run

[![Run on Google Cloud](https://storage.googleapis.com/cloudrun/button.svg)](https://console.cloud.google.com/cloudshell/editor?shellonly=true&amp;cloudshell_image=gcr.io/cloudrun/button&amp;cloudshell_git_repo=https://github.com/geshan/laravel6-on-google-cloud-run.git)
</code></pre>

<p>Be careful and replace the last part with your repo&rsquo;s <code>HTTPs</code> URL, for example, if your repo is at <code>https://github.com/ghaleroshan/laravel6-on-google-cloud-run</code> it will be <code>https://github.com/ghaleroshan/laravel6-on-google-cloud-run.git</code>, then commit and push. Your PR should look something like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/3/files">this</a> one.</p>

<h3>9. Deploy on Google Cloud Run</h3>

<p>After you merge your Pull Request (PR), then go to your repo page and click on the <code>Run on Google Cloud</code> button.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/09cloud-run-button.jpg" title="Click on the blue button to deploy the app" alt="Click on the blue button to deploy the app"></p>

<p>After that, given you are logged into your Google account and have Google cloud setup with 1 project, click &ldquo;Proceed&rdquo;. You might need to wait a bit, Then</p>

<ol>
<li>Choose the project &ndash; <code>Choose a project to deploy this application</code></li>
<li>Choose the region &ndash; <code>Choose a region to deploy this application</code>, I usually go with <code>us-central-1</code></li>
<li>Then wait for the container to be built and deployed, you can see my process below:</li>
</ol>


<p>If everything goes fine on your <code>Google Cloud Shell</code>, you will see HTTPs URL you can hit to see your
Laravel app running like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/10laravel-running-gcr.jpg" title="Hit the given URL to see its running" alt="Hit the given URL to see its running"></p>

<p>What just happened above is:</p>

<ol>
<li>After choosing the region, the script built a docker container image from the <code>Dockerfile</code> in the repo</li>
<li>Then it pushed the built image to <a href="https://cloud.google.com/container-registry/">Google Container Registry</a></li>
<li>After that using the <a href="https://cloud.google.com/sdk/gcloud/">gcloud</a> CLI it deployed the built image to Cloud Run, which gave back the URL.</li>
</ol>


<h3>10. Hurray, your app is working</h3>

<p>After you git the URL you should see your app working on Google Cloud Run like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/11laravel-url.jpg" title="Laravel Running on Google Cloud Run" alt="Laravel Running on Google Cloud Run"></p>

<p>If you want to deploy another version you can merge your PR to master and click the button again to deploy.</p>

<h2>More about Google Cloud Run</h2>

<p>The <a href="https://cloud.google.com/run/pricing">pricing</a> for Google Cloud Run is very generous. You can run any containerized app or web app on Google cloud run. I ran a pet project that got ~ 1 request per minute and I did not have to pay anything.</p>

<p>Behind the scenes, it is using <a href="https://cloud.google.com/knative/">Knative</a> and <a href="https://kubernetes.io/">Kubernetes</a>. It can also be run on your Kubernetes cluster but who would choose to manage a K8s cluster if you can just push and get scaleable serverless fully managed app :).</p>

<h2>TLDR</h2>

<p>To run Laravel 6 on Google Cloud Run quickly follow the steps below:</p>

<ol>
<li>Make sure you are logged into your <a href="https://console.cloud.google.com/">Google Cloud Account</a></li>
<li>Go to <a href="https://github.com/geshan/laravel6-on-google-cloud-run">https://github.com/geshan/laravel6-on-google-cloud-run</a></li>
<li>Click the &ldquo;Run On Google Cloud&rdquo; blue button</li>
<li>Select your project</li>
<li>Select your region</li>
<li>Wait and get the URL of your Laravel App as below, Enjoy!</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/10laravel-running-gcr.jpg" title="Hit the given URL to see its running" alt="Hit the given URL to see its running"></p>

<hr />

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/11laravel-url.jpg" title="Laravel Running on Google Cloud Run" alt="Laravel Running on Google Cloud Run"></p>

<h2>Conclusion</h2>

<p>There you go running a Laravel app on Google cloud run was pretty easy. You have even got test running on Github with Github actions. Hope it helps. To do a CI/CD approach you can check this <a href="https://medium.com/google-cloud/simplifying-continuous-deployment-to-cloud-run-with-cloud-build-including-custom-domain-setup-ssl-22d23bed5cd6">post</a>, it shows deployment using Cloud build. As the same container is running for local and production (Google Cloud Run) environment you don&rsquo;t need to learn a new framework to go Serverless.</p>

<blockquote><p>Any containerized web app can be run on Google Cloud Run, it is a great service.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Podcasts Every Software Engineer/developer Should Subscribe To - Part 4]]></title>
    <link href="https://geshan.com.np/blog/2019/07/podcasts-every-software-engineer-slash-developer-should-subscribe-to-part-4/"/>
    <updated>2019-07-08T04:58:14+00:00</updated>
    <id>https://geshan.com.np/blog/2019/07/podcasts-every-software-engineer-slash-developer-should-subscribe-to-part-4</id>
    <content type="html"><![CDATA[<p>Podcasts are a great way to learn new things even for the lazy reader. If you are not fast at reading or don&rsquo;t like it very much podcasts can be your way to get the information with less effort. It is easier than reading. This is a part 4 in the series (do check part <a href="http://geshan.com.np/blog/2015/10/3-podcasts-every-software-engineer-slash-developer-should-subscribe-to/">1</a> and
<a href="http://geshan.com.np/blog/2016/05/3-podcasts-every-software-engineer-slash-developer-should-subscribe-to-part-2/">2</a> and <a href="https://geshan.com.np/blog/2017/01/3-podcasts-every-software-engineer-slash-developer-should-subscribe-to-part-3/">3</a>) of podcasts you must subscribe to and listen to as a software engineer. Same as the last 3 times the 3 podcasts listed below have great content and considerably good sound quality too. Below is the list:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/3-podcasts-part-4/3-podcasts-sw-eng-part-04.jpg" title="3 podcasts every software engineer should subscribe to - part 4" alt="3 podcasts every software engineer should subscribe to - part 4"></p>

<!-- more -->


<h2><a href="https://spec.fm/podcasts/developer-tea">Developer Tea by Jonathan</a></h2>

<p>Developer Tea is an exceptional podcast to listen to. Jonathan sometimes does an interview and most of the times it is a discourse on software engineering related topics. A recent episode on <a href="https://spec.fm/podcasts/developer-tea/302953">Mid-Year Resolutions</a> was a strong reminder that half of the year is gone and in less than six months we will reach 2020.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/3-podcasts-part-4/developer-tea.jpg" title="Developer Tea Podcast" alt="Developer Tea Podcast"></p>

<h2><a href="http://agilenoir.biz/agilethoughts/">Agile Thoughts by Agile Noir</a></h2>

<p>Simply put Agile thought is an unconventional podcast. Don’t be scared by the unusual looking cover of the podcast, the content is good. Mostly conversational with some characters, the episodes are short and address day to day issues. I remember episode 29 <a href="https://agilenoir.biz/podcast/029-the-value-tdd-gives-to-leadership/">The value TDD gives to leadership</a> being an intriguing one.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/3-podcasts-part-4/agile-thoughts.jpg" title="Agile Thoughts Podcast" alt="Agile Thoughts Podcast"></p>

<h2><a href="https://www.intercom.com/blog/podcasts/">Inside Intercom</a></h2>

<p>Inside intercom is a superb podcast focusing on the product side of things rather than just the technical aspects. The most recent episode on <a href="https://www.intercom.com/blog/podcasts/josh-seiden-on-why-product-teams-should-focus-on-outcome-vs-output/">why product teams should focus on outcomes over output</a> was an eye-opener.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/3-podcasts-part-4/inside-intercom.jpg" title="Inside Intercom Podcast" alt="Inside Intercom Podcast"></p>

<h2>Conclusion</h2>

<blockquote><p>I hope you continue your learning journey with the above interesting podcasts. Keep learning!</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Logging best practices to get the most out of application level logging -- Slides]]></title>
    <link href="https://geshan.com.np/blog/2019/03/follow-these-logging-best-practices-to-get-the-most-out-of-application-level-logging-slides/"/>
    <updated>2019-03-26T09:02:43+00:00</updated>
    <id>https://geshan.com.np/blog/2019/03/follow-these-logging-best-practices-to-get-the-most-out-of-application-level-logging-slides</id>
    <content type="html"><![CDATA[<p>Logs from the application level are the only way your application talks back to you. Having proper logs with commendable search capabilities is like having a torch in a dark room.</p>

<p>Fully exploiting logs in case of any issues is very underrated. We as software engineers can utilize logs from the application to resolve issues as well as know the general health of the application.</p>

<blockquote><p>Logs can be instrumental to profile application performance too.</p></blockquote>

<p>I had written about <a href="https://geshan.com.np/blog/2015/08/importance-of-logging-in-your-applications/">logging</a> some years back too. This post is focused on best practices you can follow when logging from the application level and how it can help you as a software engineer.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" title="what recruiters look for" alt="what recruiters look for" data-echo="/images/logging-best-practices/logging-bp.jpg"></p>

<!-- more -->


<h2>Best practices at a glace</h2>

<p>Following are the main best practices for logging:</p>

<h3>1. Log information optimally</h3>

<p>Too much information is noise and too less information is inadequate. It is difficult to strike the balance of how much log is optimal but that is the challenge. In the case of microservices also think about traceability between services like using a unique request identifier. Another thing to keep in mind is logs are temporal, not permanent. As they are not stored in the database they usually have a life from some days to some weeks.</p>

<h3>2. Always follow severity levels</h3>

<p>An emergency means your on-call phone is going to ring at 2 AM in the morning but an info severity is something that won’t bother anyone. You have to agree as a team on some set standards like the <a href="https://tools.ietf.org/html/rfc5424">syslog one</a>.</p>

<h3>3. Structure your logs</h3>

<p>Have a structure in your log lines, like have a message and a context array to add more information about the message. Follow an agreed upon JSON standard for logging. This makes it easy to parse and search. You could even set more rules like the date is mandatory, a description cannot be more than 255 characters, extra information goes in the context. Having these simple rules makes it easier to find the log when in need. It is highly recommended to provide context with log lines like add the details of the order (things that are not sensitive of course) when logging that the order could not be shipped for instance.</p>

<h3>4. Write logs carefully  (don’t hamper performance)</h3>

<p>Make sure that adding logs does not add a lot of extra milliseconds to your response times. As far as possible write logs in an async way, logs could even be written locally in a log file and shipped using a log shipper to the service of your choice. You can also make use of tried and trusted library depending on the language/framework you are working with. Using queues could also be an option to ship logs but keep in mind the possible lag when viewing logs.</p>

<h3>5. Use the right tools for the job</h3>

<p>The tools and services you choose to ship, view, search and sort logs are your team’s choice. Depending on the budget, the appetite for using external services a team could use a fully self-managed stack like <a href="https://www.elastic.co/elk-stack">ELK</a>/<a href="https://www.graylog.org/">Graylog</a> or go full SAAS with services like <a href="https://logentries.com">Logentries</a>/<a href="https://sematext.com/logsene/">Sematext Logsense</a>. The main idea is to use the tools that fit your needs very efficiently. If you need almost real-time logs using a queue, for instance, might not be the best decision. So design your logging infrastructure and stack that fits your needs well.</p>

<h2>The slides</h2>

<p>I had done a talk at my workplace in February about “Logging best practices” and the slides from the talk are below:</p>

<script async class="speakerdeck-embed" data-id="4f33e89002cc4a29926808ef42457fc2" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


<p>You can view the slides on <a href="https://www.slideshare.net/geshan/logging-best-practices">slideshare</a> and <a href="https://speakerdeck.com/geshan/logging-best-practices">speaker deck</a> too.</p>

<h2>Conclusion</h2>

<blockquote><p>If a dog is a man’s best friend, logs are software engineer&rsquo;s best friend.</p></blockquote>

<p>Use logs to the fullest to get the most out of it and keep in mind the best practices about logging.</p>
]]></content>
  </entry>
  
</feed>
