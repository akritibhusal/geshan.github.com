<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: laravel | Geshan's Blog]]></title>
  <link href="https://geshan.com.np/blog/categories/laravel/atom.xml" rel="self"/>
  <link href="https://geshan.com.np/"/>
  <updated>2019-11-01T00:45:12+00:00</updated>
  <id>https://geshan.com.np/</id>
  <author>
    <name><![CDATA[Geshan Manandhar]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laracon AU 2019 overall a good experience]]></title>
    <link href="https://geshan.com.np/blog/2019/11/laracon-au-2019-overall-a-good-experience/"/>
    <updated>2019-11-01T09:01:15+00:00</updated>
    <id>https://geshan.com.np/blog/2019/11/laracon-au-2019-overall-a-good-experience</id>
    <content type="html"><![CDATA[<p>This is my second Laracon, the first one was <a href="https://geshan.com.np/blog/2016/08/number-laraconeu-2016-was-a-great-experience-overall/">Laracon EU 2016</a> which was one of the best conferences I have ever attended and spoken at. This blog post is a rundown of the talks of the first day of Laracon AU 2019 with slides from my talk, carry on reading…</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-au-2019/01-laracon-au-2019.jpg" title="Laracon AU 2019 stage" alt="Laracon AU 2019 stage"></p>

<!-- more -->


<h2>Day 1</h2>

<p>This is the second <a href="https://laracon.com.au/">Laracon</a> in Australia, the first one was in 2018. There were just over 200 people who attended the first day. The speaker line up looked pretty interesting with more than a couple of first-time conference speakers. TBH, no one seemed like they were taking the conference stage for the first time</p>

<h2>Talks were great</h2>

<p>The day was started by <a href="https://freek.dev/">Freek</a>, it was great meeting him after Laracon EU 2016. His talk was titled “A way to structure a large Laravel app” which is very good. The pointers on using typescript and creating a domain (kinda sub-apps) inside your Laravel were the highlights for me.</p>

<p>Then <a href="https://twitter.com/michael_timbs">Michael Tims</a> took on the stage to show how to test fronted Javascript Apps. The highlight for me was “Contract testing” in this talk as I was familiar with the regular forms of testing like unit, integration and even mutation testing. After him, <a href="https://blog.maxsnow.me/">Max Snow</a> showed us his Laravel API boilerplate and how it makes creating APIs on Laravel easy. Then it was me on stage and details about my talk “Are logs a software engineer’s best friend? Yes &ndash; follow these best practices” are below.</p>

<p>After lunch, <a href="https://jessarcher.com/">Jess Archer</a> spread her knowledge of SPAs, the highlight for me was using JWT token in cookies. As I have done it in the past it was easier for me to relate to the concept. Then <a href="https://samgreenwood.me/">Sam</a> took the stage to show us the need for strict types and tools in PHP to do it. I liked the multiple tools he mentioned like <a href="http://psalm.dev">Psalm</a>. After him, <a href="https://jessbudd.com">Jess Budd</a> showed us how to write semantic HTML to build apps accessible with screen readers. The main takeaway for me here was semantic HTML not only improves accessibility but also add more SEO juice to your website.</p>

<p>After the break, <a href="https://amyskapers.tech/">Amy</a> took on the stage to show us the magic of CSS grids. The main highlight for me was it helped me demystify the seemingly magical CSS grids. Last but not least was <a href="https://jasonmccreary.me/">JMac</a> (creater of Laravel <a href="https://laravelshift.com/">Shift</a>) giving us important pointers to “Creating maintainable Laravel applications”. He had 10 points to do so. My main takeaway was “grok the framework” if I was writing Laravel every day that is something I would remember and follow :)</p>

<p>You can follow all the tweets/images at <a href="https://twitter.com/search?q=%23laraconau">#laraconau</a> on twitter. Special thanks to <a href="https://twitter.com/shanesmithau">Shane Smith</a> for his amazing threads on twitter. I don’t know how he is tweeting, listening and taking pictures at the same time :).</p>

<h2>My talk</h2>

<p>I think my talk went pretty well too. There was no time or provision to ask a question which is Ok. Some people came in later to ask their queries about logging and how to get started. I consider that the talk was warmly received by the audience with some laughs and a lot of attention.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-au-2019/02-laracon-au-2019.jpg" title="My talk about Logging at Laracon AU 2019" alt="My talk about Logging at Laracon AU 2019"></p>

<h2>Slides</h2>

<p>Below are the slides from my talk:</p>

<script async class="speakerdeck-embed" data-id="26f9b284425c4048a8aa587e155636ce" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


<p>The slides are on <a href="https://www.slideshare.net/geshan/are-logs-a-software-engineers-best-friend-yes-follow-these-best-practices">slide share</a> too.</p>

<h2>Day 2</h2>

<p>Today is day 2 and let&rsquo;s see how it goes. <a href="https://twitter.com/marcusamoore">Marcus</a> is going to start the day.</p>

<h2>Conclusion</h2>

<p>Day 1 was good overall. One thing I noticed was the number of female attendees was quite low. This is something the organizers can work on else the venue, organization of the speakers and attendees was commendable. Thanks to <a href="https://twitter.com/michaeldyrynda">Michael</a> and the team for putting up such a great tech conference in Sydney bringing together like-minded technologists under the same roof. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set up Laravel 6 on Google Cloud Run step by step with Continuous Integration (CI)]]></title>
    <link href="https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci/"/>
    <updated>2019-10-21T08:03:29+00:00</updated>
    <id>https://geshan.com.np/blog/2019/10/get-laravel-6-running-on-google-cloud-run-step-by-step-with-ci</id>
    <content type="html"><![CDATA[<p>Laravel has <a href="https://trends.google.com/trends/explore?date=2014-10-22%202019-10-21&amp;q=laravel,symfony">soared</a> in popularity in the last few years. The Laravel community even says that Laravel has made writing PHP enjoyable than a pain. Laravel 6 has some interesting new <a href="https://laracasts.com/series/whats-new-in-laravel-6">features</a>. Getting a super scaleable working URL for your application take hours if not days. Setting up something like Kubernetes is a huge task. This is where Google Cloud Run shines, you can get a working HTTPs URL for any of your containerized app in minutes.</p>

<p><a href="https://cloud.google.com/run/">Google Cloud Run</a> is serverless and fully managed by Google, you get super scale, billing by the second, HTTPs URL and your own domain mapping. If you want to run stateless containers Cloud run is hands down the easiest way to do it. In this post, I will detail how to get your Laravel 6 app working on Google cloud run with Continous Integration (CI).</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/00laravel6-on-gcr.jpg" title="Get Laravel 6 running on Google cloud run in minutes with CI" alt="Get Laravel 6 running on Google cloud run in minutes with CI"></p>

<!-- more -->


<h2>Prerequisites</h2>

<ul>
<li>You are familiar with PHP/Composer and aware of Laravel (if you&rsquo;ve landed here you are I suppose)</li>
<li>You know how to use Git from the CLI</li>
<li>Your code is hosted on GitHub for CI/CD and you are familiar with GitHub</li>
<li>Know a fair bit of docker, maybe even multi-stage build</li>
<li>Have a working Google cloud account (they give you <a href="https://cloud.google.com/free/">$300 credit</a> free for 1 yr, no reasons not to have an account)</li>
</ul>


<h2>Why is Cloud Run a great option for beginners</h2>

<p>For two reasons as mentioned below</p>

<ol>
<li>Learn about the best practices and software like docker and CI/CD</li>
<li>Getting the basics going is click a button, select 2 things wait for 5 mins you get a working HTTPs URL. Can it be any easier than this :)</li>
</ol>


<h2>Steps to deploy</h2>

<p>Below are the steps to set up and deploy Laravel 6 on Cloud Run:</p>

<h3>1. Clone Laravel or new Laravel project</h3>

<p>Start by cloning Laravel or using composer or the Laravel CLI as indicated in the official <a href="https://laravel.com/docs/5.8/installation">installation</a> guide. I am using composer to get the latest Laravel as below:</p>

<h4>Command</h4>

<p>I ran the following command to get the latest laravel:</p>

<pre><code class="bash">composer create-project --prefer-dist laravel/laravel laravel6-on-google-cloud-run
</code></pre>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/01install-laravel.jpg" title="Installing Laravel with composer" alt="Installing Laravel with composer"></p>

<h3>2. Test it locally first</h3>

<p>Then run <code>cd laravel6-on-google-cloud-run</code> then <code>php artisan serve</code> to see if it is working, for me it was fine when I went to <code>http://localhost:8000</code> on a web browser. I had PHP 7.2 installed locally.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/02running-laravel.jpg" title="Running Laravel locally" alt="Running Laravel locally"></p>

<h3>3. Create a new GitHub repo</h3>

<p>Create a new repository on Github like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/03github-repo.jpg" title="Creating a repo for Laravel on Github" alt="Creating a repo for Laravel on Github"></p>

<p>You can use any Git hosting provider, for this example I will be using <a href="https://github.com/features/actions">Github Actions</a> to run tests and Github is the most popular git hosting too.</p>

<h3>4. Add repo, push readme</h3>

<p>Now after you have the repo created, add it to your local Laravel copy and push the Readme file. To do this
run the following commands on your cli:</p>

<pre><code>git init
code . # I used VS code to change the readme
git add readme.md
git commit -m "Initial commit -- App Readme"
git remote add origin git@github.com:geshan/laravel6-on-google-cloud-run.git
git push -u origin master
</code></pre>

<h4>After running the above commands I had this on my github repo</h4>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/04initial-push.jpg" title="After the first push, repo looks like this" alt="After the first push, repo looks like this"></p>

<h3>5. Add full Laravel, open PR</h3>

<p>Now let&rsquo;s add the whole app as a PR to the Github repo by executing the following commands:</p>

<pre><code class="bash">git checkout -b laravel6-full-app
git add .gitignore
git add .
git commit -m "Add the whole Laravel 6 app"
git push origin laravel6-full-app
</code></pre>

<p>After that go and open a Pull Request (PR), on the repo like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/1">this</a> one. You might be thinking I am the only one working on this, why
do I need a PR? Well, it is always better to do things methodically even if it is just one person working on the project :).</p>

<p>After that merge your pull request.</p>

<h3>6. Setup tests with <a href="https://github.com/features/actions">GitHub actions</a></h3>

<p>Not some fun part, after you merged your PR now Github knows that this is a Laravel project. Click on  <code>Actions</code> tab on your repo page and you should be able to see something like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/05github-actions.jpg" title="Click Actions tab to view options" alt="Click Actions tab to view options"></p>

<p>Click the <code>Set up this workflow</code> under <code>Laravel</code> then on the next page click <code>Start commit</code> button on the top right. After that add a commit message like below and click <code>Commit new file</code>.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/06gh-actions-ci.jpg" title="Add Laravel tests action" alt="Add Laravel tests action"></p>

<p>There you go, you have your CI setup. Laravel default tests will run on each git push now. Wasn&rsquo;t that easy? Thank Github for this great intelligence. No more creating <code>.myCIname.yml</code> file anymore :).</p>

<h3>7. Add docker and docker-compose to run app locally</h3>

<p>Now let&rsquo;s add docker and docker-compose to run the app locally without PHP or artisan serve. We will need the container to run Laravel on Google Cloud Run too. This part is inspired by <a href="https://nsirap.com/posts/010-laravel-on-google-cloud-run/">Laravel on Google Cloud Run</a> post by Nicolas. If you want to learn more about <a href="https://www.docker.com/">Docker</a> and Laravel please refer to this <a href="https://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker/">post</a>.</p>

<p>Run the following commands first to get your master up to date as we added the <code>workflow</code> file from Github interface:</p>

<pre><code>git checkout master
git fetch
git pull --rebase origin master # as we added the workflow file from github interface
git checkout -b docker
</code></pre>

<p>Add a key to the <code>.env.example</code> file, copy it from <code>.env</code> file like below:</p>

<pre><code>APP_NAME=Laravel
APP_ENV=local
APP_KEY=base64:DJkdj8L5Di3rUkUOwmBFCrr5dsIYU/s7s+W52ClI4AA=
APP_DEBUG=true
APP_URL=http://localhost
</code></pre>

<p>As this is just a demo this is ok to do, for a real app always be careful with secrets.
For production-ready apps do turn of the debugging and other dev related things.</p>

<p>Add the following <code>Dockerfile</code> on the project root:</p>

<pre><code>FROM composer:1.9.0 as build
WORKDIR /app
COPY . /app
RUN composer global require hirak/prestissimo &amp;&amp; composer install

FROM php:7.3-apache-stretch
RUN docker-php-ext-install pdo pdo_mysql

EXPOSE 8080
COPY --from=build /app /var/www/
COPY docker/000-default.conf /etc/apache2/sites-available/000-default.conf
COPY .env.example /var/www/.env
RUN chmod 777 -R /var/www/storage/ &amp;&amp; \
    echo "Listen 8080" &gt;&gt; /etc/apache2/ports.conf &amp;&amp; \
    chown -R www-data:www-data /var/www/ &amp;&amp; \
    a2enmod rewrite
</code></pre>

<p>Then add the following file at <code>docker/000-default.conf</code></p>

<pre><code>&lt;VirtualHost *:8080&gt;

    ServerAdmin webmaster@localhost
    DocumentRoot /var/www/public/

    &lt;Directory /var/www/&gt;
      AllowOverride All
      Require all granted
    &lt;/Directory&gt;

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

&lt;/VirtualHost&gt;
</code></pre>

<p>After that add the following <code>docker-compose.yml</code></p>

<pre><code>version: '3'
services:
  app:
    build:
      context: ./
    volumes:
      - .:/var/www
    ports:
      - "8080:8080"
    environment:
      - APP_ENV=local
</code></pre>

<h4>Boil down to main things</h4>

<p>If you try to understand everything here it might be overwhelming, let me boil down the main parts:</p>

<ol>
<li>We are using the official PHP Apache docker image to run Laravel, it has PHP version 7.3.</li>
<li>We are using multistage build to get the dependencies with Composer then copying them to the main docker image that has PHP 7.3 and Apache.</li>
<li>As Google Cloud Run requires the web-server to be listening to port <code>8080</code> we are using <code>000-default.conf</code> to configure this</li>
<li>To make things easy to run with single command <code>docker-compose up</code> we are using docker-compose.</li>
<li>Now as you have read this far, run <code>docker-compose up</code> on your root and then after everything runs go to <code>http://localhost:8080</code> to see that Laravel 6 is running locally on Docker. Below is my <code>docker-compose up</code> output towards the end:</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/07docker-compose-output.jpg" title="Docker compose running Laravel with PHP 7.3 and Apache" alt="Docker compose running Laravel with PHP 7.3 and Apache"></p>

<p>As Laravel is running fine with Docker, let&rsquo;s open a PR like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/2/files">this</a> one to add Docker to our project. I ran the following commands on the root of the project before opening the Pull Request (PR):</p>

<pre><code>git status
</code></pre>

<p>It should give you something like below:</p>

<pre><code>On branch docker
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)

    Dockerfile
    docker-compose.yml
    docker/

nothing added to commit but untracked files present (use "git add" to track)
</code></pre>

<p>Now run the following commands:</p>

<pre><code>git add .
git commit -m "Add docker and docker compose"
git push origin docker
</code></pre>

<p>As a bonus it will run the Laravel default test on the push, like you can see below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/08test-running-gh.jpg" title="On each push PHP unit test will run" alt="On each push PHP unit tests will run"></p>

<p>Only the owner of the repo has access to the <code>Actions</code> tab so other people don&rsquo;t necessarily need to know the results of your test builds :).</p>

<h3>8. Add deploy to <a href="https://github.com/GoogleCloudPlatform/cloud-run-button">Google Cloud button</a></h3>

<p>Now let&rsquo;s deploy this Laravel setup to Google Cloud Run the easy way. Given you have merged your PR from the <code>docker</code> branch. Let&rsquo;s run the following commands:</p>

<pre><code>git checkout master
git fetch
git pull --rebase origin master
git checkout -b cloud-run-button
</code></pre>

<p>Then add the following to your <code>readme.md</code> file:</p>

<pre><code>### Run on Google cloud run

[![Run on Google Cloud](https://storage.googleapis.com/cloudrun/button.svg)](https://console.cloud.google.com/cloudshell/editor?shellonly=true&amp;cloudshell_image=gcr.io/cloudrun/button&amp;cloudshell_git_repo=https://github.com/geshan/laravel6-on-google-cloud-run.git)
</code></pre>

<p>Be careful and replace the last part with your repo&rsquo;s <code>HTTPs</code> URL, for example, if your repo is at <code>https://github.com/ghaleroshan/laravel6-on-google-cloud-run</code> it will be <code>https://github.com/ghaleroshan/laravel6-on-google-cloud-run.git</code>, then commit and push. Your PR should look something like <a href="https://github.com/geshan/laravel6-on-google-cloud-run/pull/3/files">this</a> one.</p>

<h3>9. Deploy on Google Cloud Run</h3>

<p>After you merge your Pull Request (PR), then go to your repo page and click on the <code>Run on Google Cloud</code> button.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/09cloud-run-button.jpg" title="Click on the blue button to deploy the app" alt="Click on the blue button to deploy the app"></p>

<p>After that, given you are logged into your Google account and have Google cloud setup with 1 project, click &ldquo;Proceed&rdquo;. You might need to wait a bit, Then</p>

<ol>
<li>Choose the project &ndash; <code>Choose a project to deploy this application</code></li>
<li>Choose the region &ndash; <code>Choose a region to deploy this application</code>, I usually go with <code>us-central-1</code></li>
<li>Then wait for the container to be built and deployed, you can see my process below:</li>
</ol>


<p>If everything goes fine on your <code>Google Cloud Shell</code>, you will see HTTPs URL you can hit to see your
Laravel app running like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/10laravel-running-gcr.jpg" title="Hit the given URL to see its running" alt="Hit the given URL to see its running"></p>

<p>What just happened above is:</p>

<ol>
<li>After choosing the region, the script built a docker container image from the <code>Dockerfile</code> in the repo</li>
<li>Then it pushed the built image to <a href="https://cloud.google.com/container-registry/">Google Container Registry</a></li>
<li>After that using the <a href="https://cloud.google.com/sdk/gcloud/">gcloud</a> CLI it deployed the built image to Cloud Run, which gave back the URL.</li>
</ol>


<h3>10. Hurray, your app is working</h3>

<p>After you git the URL you should see your app working on Google Cloud Run like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/11laravel-url.jpg" title="Laravel Running on Google Cloud Run" alt="Laravel Running on Google Cloud Run"></p>

<p>If you want to deploy another version you can merge your PR to master and click the button again to deploy.</p>

<h2>More about Google Cloud Run</h2>

<p>The <a href="https://cloud.google.com/run/pricing">pricing</a> for Google Cloud Run is very generous. You can run any containerized app or web app on Google cloud run. I ran a pet project that got ~ 1 request per minute and I did not have to pay anything.</p>

<p>Behind the scenes, it is using <a href="https://cloud.google.com/knative/">Knative</a> and <a href="https://kubernetes.io/">Kubernetes</a>. It can also be run on your Kubernetes cluster but who would choose to manage a K8s cluster if you can just push and get scaleable serverless fully managed app :).</p>

<h2>TLDR</h2>

<p>To run Laravel 6 on Google Cloud Run quickly follow the steps below:</p>

<ol>
<li>Make sure you are logged into your <a href="https://console.cloud.google.com/">Google Cloud Account</a></li>
<li>Go to <a href="https://github.com/geshan/laravel6-on-google-cloud-run">https://github.com/geshan/laravel6-on-google-cloud-run</a></li>
<li>Click the &ldquo;Run On Google Cloud&rdquo; blue button</li>
<li>Select your project</li>
<li>Select your region</li>
<li>Wait and get the URL of your Laravel App as below, Enjoy!</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/10laravel-running-gcr.jpg" title="Hit the given URL to see its running" alt="Hit the given URL to see its running"></p>

<hr />

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel6-on-google-cloud-run/11laravel-url.jpg" title="Laravel Running on Google Cloud Run" alt="Laravel Running on Google Cloud Run"></p>

<h2>Conclusion</h2>

<p>There you go running a Laravel app on Google cloud run was pretty easy. You have even got test running on Github with Github actions. Hope it helps. To do a CI/CD approach you can check this <a href="https://medium.com/google-cloud/simplifying-continuous-deployment-to-cloud-run-with-cloud-build-including-custom-domain-setup-ssl-22d23bed5cd6">post</a>, it shows deployment using Cloud build. As the same container is running for local and production (Google Cloud Run) environment you don&rsquo;t need to learn a new framework to go Serverless.</p>

<blockquote><p>Any containerized web app can be run on Google Cloud Run, it is a great service.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[LaraconEU 2016 was a great experience overall]]></title>
    <link href="https://geshan.com.np/blog/2016/08/number-laraconeu-2016-was-a-great-experience-overall/"/>
    <updated>2016-08-25T03:59:03+00:00</updated>
    <id>https://geshan.com.np/blog/2016/08/number-laraconeu-2016-was-a-great-experience-overall</id>
    <content type="html"><![CDATA[<p>It all started with submitting my chatops talk to some open call for papers in April 2016. After giving the talk in CodeMotion Dubai, I felt chatops is a useful topic. Everyone working in software development can leverage it to make their life easier. My talk was a Laravel centered version of the same talk.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-eu-2016/laracon-eu.jpg" title="Laracon EU 2016" alt="Laracon EU 2016"></p>

<!-- more -->


<h2>Talk Accepted - Woo hoo!</h2>

<p>My talk got accepted in around mid-May for <a href="https://twitter.com/search?q=%23LaraconEU&amp;src=tyah">#LaraconEu</a> 2016. It was amazing news that entailed other things to take care of. I had to sort out visa first. I want to thank Shawn for keeping like 3 months + time between paper selection and the conference. This is great for speakers like me who have to sort out the paperwork. It is also useful for speakers who get enough time to prepare for their talk.</p>

<blockquote><p>It is something that all conference organizers should  consider when organizing an &ldquo;international&rdquo; conference. Select speakers/talks like 3 months or more in advance.</p></blockquote>

<h3>Suggestions to conference organizers</h3>

<p>Then after I confirmed my presence, I started taking care of the paperwork for the visa. I also had a chat with Shawn over Skype. He gave me some pointers to make the talk more suited to the Laravel Developers audience. It was super handy.</p>

<p>Along the same lines I have 3 more suggestions to conference organizers:</p>

<ol>
<li>Have a conversation with speaker after talk selection. Advise them about content.</li>
<li>Don&rsquo;t always strive for fresh content. The speaker might have presented it earlier. Think of how the speaker can mold it to suit your conference audience.</li>
<li>Be adventurous with speaker selection. I agree it&rsquo;s a risk to select a speaker who needs a visa to be at the conference venue. Still, if you give enough time like ~3 months things generally work out :).</li>
<li>Give speakers with potential a chance, have that trust.</li>
</ol>


<h2>Conference Experience</h2>

<p>Let&rsquo;s fast forward to 22-Aug-2016 now, I arrived in Amsterdam. I am here in Amsterdam after 5 years, still seems like nothing much has changed here :). I can&rsquo;t write anything about the workshops as I did not attend it. The organizers were well prepared. All speakers already had access to the speaker&rsquo;s handbook. The telegram group was useful too.</p>

<p>Most speakers were staying at Park Vitoria Hotel. It is right infornt of Amsterdam Central. 15 mins train ride from the venue and I must tell you its a great hotel to be in.</p>

<h3>Speaker&rsquo;s dinner</h3>

<p>The ice breaking speaker dinner was great. Speakers interacted and got along well with each other. I guess they also changed their selected talks to attend talking with other speakers. I want to thank the organizers of Laracon EU for the effort they put into speaker hospitality.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-eu-2016/speaker-dinner.jpg" title="On the way to the restaurant for speaker dinner" alt="On the way to the restaurant for speaker dinner"></p>

<h3>Conference Day 1</h3>

<p>Day 1 on 23-Aug-2016 kicked off like half an hour late due to minor technical issues. Taylor Otwell rocked the stage as usual. One thing, I noticed is even a seasoned speaker like Taylor gets a bit nervous before going to stage. So for us rookie speakers it is absolutely  normal to be nervous.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-eu-2016/taylor-laracon-eu.jpg" title="Taylor Otwell with his keynote at Laracon EU 2016" alt="Taylor Otwell with his keynote at Laracon EU 2016"></p>

<p>Then I attended the talk by Hannes Van De Vreken about IOC Containers. The talk was quite helpful. We took the train together to the venue. Still, I was preparing for my talk that was after lunch.</p>

<p>My turn was next after lunch. Ubuntu wasn&rsquo;t helping much with the huge display that needed 50 Hz refresh rate. After some googling, it played out well without issues.  My talk went pretty smooth and I even got a few questions a the end. I guess I managed my time well.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-eu-2016/geshan-laracon-eu.jpg" title="Me talking about Chatops at Laracon EU 2016" alt="Me talking about Chatops at Laracon EU 2016">
More pictures from my talk <a href="https://www.facebook.com/media/set/?set=a.10154031202522979.1073741829.625427978&amp;type=1&amp;l=48cf6b4aa3">here</a>.</p>

<p>The slides of my talk are below:</p>

<script async class="speakerdeck-embed" data-id="9df0de20135d458ca8bd818176afbdca" data-ratio="1.77777777777778" src="//speakerdeck.com/assets/embed.js"></script>


<p><a href="http://bit.ly/chatops-slides-leu">Slideshare link</a></p>

<p>I wrote a small script to pull in the latest tweet with #LaraconEu for the demo which is <a href="https://github.com/geshan/larabot-hubot">here</a>.</p>

<h2>Video Of My Talk on Chatops</h2>

<iframe width="560" height="315" src="https://www.youtube.com/embed/SZ3UfwBACIo" frameborder="0" allowfullscreen></iframe>


<p>After that I attended the following talks for the day:</p>

<ol>
<li>How to avoid database migration hell - which was good</li>
<li>Varnish For PHP Developers - that was a bit of too much code still good</li>
<li>One Box Doesn&rsquo;t fit all - by Frank which was a different way at looking at scalability, still, it was a great talk.</li>
</ol>


<h3>Conference Day 2</h3>

<p>I was more relaxed on day 2, I had no talk to do. Then I focused on getting the best out of the day. Below are the talks I attended:</p>

<ol>
<li>Please Understand Me by Matthias Noback - Great talk about the tussle between Mangers and Developers</li>
<li>Lucid Architecture By Abed Halawi - Good concepts and well presented</li>
<li>Building Realtime apps NodeJs way By Sriram - He had too many slides so I was lost mid-way :)</li>
<li>Making the most out of MYSQL By Gabi - A great talk, good content and well presented. The experience of the presenter was visible on stage.</li>
<li>The State of content management By Tihomir - Generally a good talk, as I told to him the contents could be condensed better.</li>
<li>Curing the common Loop By Adam Wathan - Amazing talk a good mix of slides and live coding. Collections seems like the lodash of PHP world.</li>
</ol>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laracon-eu-2016/adam-laracon-eu.jpg" title="Adam talking about Curing Loops at Laracon EU 2016" alt="Adan talking about Curing Loops at Laracon EU 2016"></p>

<p>For more description of the above talks it&rsquo;s best to have a look at the Laracon EU 2016 <a href="http://laracon.eu/2016/schedule">schedule</a>.</p>

<p>The after party on day 2 was superb too. With live band performing and tech conversations around the atmosphere was electric.</p>

<p>For more photos from the conference do checkout the #LaraconEu tag with <a href="https://twitter.com/search?f=images&amp;vertical=default&amp;q=%23LaraconEU&amp;src=tyah">photos</a>.</p>

<h2>Amazing Experience</h2>

<p>Overall, it was an amazing experience. The venue was great. Organizers put a lot of effort to make sure the speakers felt comfortable. I
want to thank them. The comments I have received over <a href="https://joind.in/talk/9999a">JoinedIn</a> about my talk have been very helpful, I would really like
more ratings and comments :).</p>

<blockquote><p>I am waiting for the videos like everyone else, I have some talks I missed that I want to watch. I loved being a part of such a vibrant event backed by
an amazing community. Cheers!</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting started with Laravel, MariaDB (MySQL) and docker, docker compose]]></title>
    <link href="https://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker/"/>
    <updated>2015-10-24T07:49:48+00:00</updated>
    <id>https://geshan.com.np/blog/2015/10/getting-started-with-laravel-mariadb-mysql-docker</id>
    <content type="html"><![CDATA[<p>&ldquo;How do I get new team members contributing code to the project in a matter of minutes/hours not days?&rdquo; is a common question heard in development teams. There are some ways to do, in my opinion <a href="http://docker.com">docker</a> is one of the best.</p>

<p>Docker enables using same software stack in development, staging and production. You don&rsquo;t need to worry about the version of PHP, MYSQL or any other dependency with Docker. This post will be about Laravel and MariaDB (MySQL) with Docker for local development. It will also feature use of docker-compose. We will use PHP 5.6 and MariaDB 10.1 with Laravel 5.1.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-mysql-docker/laravel-mysql-docker.png" title="Getting started with Laravel, MariaDB (MySQL) and docker, docker compose" alt="Getting started with Laravel, MariaDB (MySQL) and docker, docker compose"></p>

<!-- more -->


<h2>Prerequisites</h2>

<ul>
<li>You are aware about docker and is basic usage. If you are new to docker check an <a href="http://bit.ly/1LsQ4X6">introduction screen-cast</a>) or read this <a href="http://bit.ly/1FVjL0k">Docker for PHP Developers</a> post</li>
<li>You know about docker volumes and linking containers with docker-compose.</li>
<li>You are running Laravel 5.x on your local machine with some PHP and MySQL setup. The setup can be local LEMP stack or XAMPP or something similar.</li>
<li>You have docker and <a href="https://docs.docker.com/compose/install/">docker compose</a> installed on your machine</li>
<li>You have stopped your Apache/Nginx service and MYSQL service. It will free port 80 and 3306. If
you are using vagrant and homestead then you can run Laravel without starting it.</li>
</ul>


<h2>Software Versions used</h2>

<p>I am running this example on Ubuntu 14.04.2 LTS.</p>

<ul>
<li>Docker : 1.7.1 (<a href="https://docs.docker.com/installation/">Installation Instructions</a>)</li>
<li>Docker compose : 1.3.1 (<a href="https://docs.docker.com/compose/install/">Installation Instructions</a>)</li>
</ul>


<h2>Why use docker?</h2>

<p>The reasons to use docker are simiar to <a href="http://geshan.com.np/blog/2014/07/getting-started-with-php-lemp-on-vagrant/">vagrant</a>. There are some more compelling reasons to use docker and docker compose, some of them are:</p>

<h3>Quick setup of development environment</h3>

<p>The developer/software engineer does not need to know which version of PHP or MySQL is in use. All s/he needs to do is <code>docker-compose up</code> and wait for the images to download (around 230 MB). After that add a entry to the /etc/hostsfile like <code>echo 127.0.0.1 project-name.dev &gt;&gt; /etc/hosts</code>. Then the project runs at <code>http://project-name.dev</code> on the browser.</p>

<h3>No need to install software on local machine</h3>

<p>With docker containers applications are self sufficient. There is no need to upgrade to the latest version of PHP or MySQL. The right version is already packaged inside the dockerfile and also in the container. There is no problem of one developer running PHP 5.5 and another one running PHP 5.6. All developers run the same container. You can install PHP to run composer and other scripts.</p>

<h3>Same software stack in all environments</h3>

<p>Same docker container can be deployed to staging or production environments. The same software stack with correct software versions is used across environments. For example the problem of one developer using MySQL 5.6 and staging running MySQL 5.5 ends.</p>

<p>A <a href="https://github.com/jwilder/nginx-proxy">NGINX proxy</a> can be used to make the virtual hosts dynamic. This post is about keeping things simple.</p>

<h2>Steps to running Laravel 5.x with MariaDB (MySQL) with docker</h2>

<p>For this example I will use docker images with <a href="https://hub.docker.com/_/alpine/">Alpine Linux</a> base images. Alpine image is just 5 MB which makes it the best candidate for docker base images. We will use PHP version 5.6 and MariaDB version 10.1. MariaDB is a drop in replacement of MySQL and for Alpine only MariaDb is available. The example git repo for this blog post is available on <a href="https://github.com/geshan/laravel-mysql-docker">github</a>.</p>

<h3>Install Laravel 5.1 on local machine</h3>

<p>Run the following command:</p>

<pre><code>composer create-project laravel/laravel --prefer-dist laravel-mysql-docker
</code></pre>

<p>I installed it on <code>~/Projects/misc/laravel-mysql-docker</code></p>

<h3>Add larael-docker.dev to /etc/hosts</h3>

<p>While it is downloading Laravel add <code>127.0.0.1 larave-docker.dev</code> to your <code>/etc/hosts</code> file. It can be
done quickly with the command below:</p>

<pre><code>sudo echo '120.0.0.1 laravel-docker.dev' &gt;&gt; /etc/hosts
</code></pre>

<h3>Setup docker images with docker-compose</h3>

<p>We will use <a href="https://github.com/dydx/alpine-nginx-php-mariadb">dydx/alpine-nginx-php-mariadb</a> and modify it to suit our needs. It is a docker replacement for homestead. Both docker images are based on Alpine Linux which makes it small. Create the following <code>docker-compose.yml</code> file on root of the project:</p>

<pre><code>front:
  image: dydx/alpine-nginx-phpfpm
  ports:
    - "80:80"
  volumes:
    - .:/var/www
    - docker/nginx/sites-enabled:/etc/nginx/sites-enabled
  links:
    - mysql:mysql

mysql:
  image: dydx/alpine-mariadb
  ports:
    - "3306:3306"
  volumes:
    - docker/db/data:/var/lib/mysql
</code></pre>

<ul>
<li>We are using dydx/alpine-nginx-phpfpm image named as front, it has PHP Nginx 1.8 and PHP-FPM.</li>
<li>It uses supervisor to keep nginx and PHP-FPM running.</li>
<li>We copy the all the files in current folder inside docker at <code>/var/www</code> to execute it.</li>
<li>Other volumes are there to override the sites-enabled with virtual host and supervisor config to fix an error.</li>
<li>The second definition is MySQL for which the data is saved in ./docker/db/data folder.</li>
<li>The front container links the MySQL (MariaDB) container with the name <code>mysql</code></li>
</ul>


<h3>Create needed folders</h3>

<p>In project root create the following folders:</p>

<pre><code>./docker
./docker/db
./docker/nginx
./docker/nginx/sites-enabled
</code></pre>

<p>All MYSQL/MariaDB data that would generally be stored in <code>/var/lib/mysql</code> will be linked as volume from <code>./docker/db</code>.
This is done as docker containers don&rsquo;t have data persistence. This will keep the MySQL data persisted on the host machine which will be reused when the MySQL/MariaDB container is restarted. The folder structure should
be like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-mysql-docker/folder-structure.png" title="Laravel, MariaDB (MySQL) and docker, docker compose folder structure" alt="Laravel, MariaDB (MySQL) and docker, docker compose folder structure"></p>

<h3>Create default sites-enabled</h3>

<p>Create a file named <code>default</code> on <code>./docker/nginx/sites-enabled</code> like below:</p>

<pre><code>server {
  server_name laravel-docker.dev;
  root        /var/www/public;
  index       index.php;

  client_max_body_size 100M;
  fastcgi_read_timeout 1800;

  location / {
    try_files $uri $uri/ /index.php$query_string;
  }

  location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ {
    expires       max;
    log_not_found off;
    access_log    off;
  }

  location ~ \.php$ {
    try_files     $uri =404;
    include       fastcgi_params;
    fastcgi_index index.php;
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    fastcgi_pass  127.0.0.1:9000;
  }
}
</code></pre>

<h3>Run Docker compose up</h3>

<p>Now give you are in the project root, you can run <code>docker-compose up</code> to build and run the containers.
Wait for the containers to download. You can do more customization if you create your own image and do a
docker-compose build to build the images.</p>

<p>After you run docker-compose up you will see output like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-mysql-docker/docker-compose-up.png" title="Laravel, MariaDB (MySQL) and docker, docker compose up output" alt="Laravel, MariaDB (MySQL) and docker, docker compose up output"></p>

<h3>Fix permissions</h3>

<p>The containers are up still as the cache and logs are not writable it will hit a 500 Internal server
error. To fix this use the following command to relax the file permissions inside the container in a
new console tab.</p>

<pre><code>docker exec -it laravelmysqldocker_front_1 chmod 0777 /var/www/storage -R
</code></pre>

<p>or it can be done locally too with the following command:</p>

<pre><code>chmod 0777 /var/www/storage -R
</code></pre>

<p>If you want to run your artisan commands you can run them inside the front container. Hit the command below:</p>

<pre><code>docker exec -it laravelmysqldocker_front_1 /bin/sh
</code></pre>

<p>You will get the shell of the front container then do <code>cd /var/www</code> and <code>php artisan</code> all your artisan commands are there.</p>

<h3>Access <a href="http://http://laravel-docker.dev">http://http://laravel-docker.dev</a></h3>

<p>You should be able to load Laravel in the browser now navigating to <code>http://laravel-docker.dev</code>. Here you can see the Laravel 5 default page loading.</p>

<h2>MySQL Settings</h2>

<p>You can check if MySQL/MariaDB is running by logging into MySQL locally with:</p>

<pre><code>mysql -uhomestead -psecret homestead
</code></pre>

<p>This will connect to you local port 3306 and you can see that mysql is working. You can even use tools like
MySQL workbench to verify that MySQL is working fine.</p>

<p>From the container when you connect to MySQL the <code>DB_HOST</code> is not localhost anymore it should be <code>mysql</code> (as set in docker-compose.yml file) and you are all set to use MySQL. As an example have a look at the db part of .env file I used:</p>

<pre><code>DB_HOST=mysql
DB_DATABASE=homestead
DB_USERNAME=homestead
DB_PASSWORD=secret
</code></pre>

<p>The easiest way to verify if Laravel is talking to MySQL/MariaDb correctly is just run the following command:</p>

<pre><code>docker exec -it laravelmysqldocker_front_1 /bin/sh

## you will be inside the front container now

cd /var/www/

php artisan migrate
</code></pre>

<p>Then you will see some messages like below:</p>

<pre><code>Migration table created successfully.
Migrated: 2014_10_12_000000_create_users_table
Migrated: 2014_10_12_100000_create_password_resets_table
</code></pre>

<p>Now run the following queries on MySQL/MariaDb via the cli client or some other client like MySQL Workbench.</p>

<pre><code>use homestead;
describe users;
</code></pre>

<p>You will get an output like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-mysql-docker/users-table.png" title="Laravel, MariaDB (MySQL) and docker, docker compose users table" alt="Laravel, MariaDB (MySQL) and docker, docker compose users table"></p>

<h3>Stop docker containers</h3>

<p>You have seen that docker is running from the containers. To stop your containers you should run:</p>

<pre><code>docker-compose stop
</code></pre>

<p>on the project root and it will stop the containers like below:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-mysql-docker/docker-compose-stop.png" title="Laravel, MariaDB (MySQL) and docker, docker compose stop output" alt="Laravel, MariaDB (MySQL) and docker, docker compose stop output"></p>

<h2>Next Steps</h2>

<p>You can carry on using the docker containers to replace your local Apache/Ngnix and MySQL. You can develop your Laravel applicaiton with ease using docker and docker compose.</p>

<h2>Conclusion</h2>

<blockquote><p>You can use this analogy that containers are cattle and virtual machines (VMs) are pets.</p></blockquote>

<p>Creating, deleting and reconstructing the containers should be easy, fast and seamless than VMs.
If you want to speed up your development flow and help other team members contribute faster to the project
opt for docker and docker-comopse. Happy Dockerizing and coding Laravel + PHP!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting started with unit testing in Laravel]]></title>
    <link href="https://geshan.com.np/blog/2015/07/getting-started-with-unit-testing-in-laravel/"/>
    <updated>2015-07-25T04:57:42+00:00</updated>
    <id>https://geshan.com.np/blog/2015/07/getting-started-with-unit-testing-in-laravel</id>
    <content type="html"><![CDATA[<p>Automated Testing an application is kind of a puzzle given the choice of methodologies (TDD, BDD&hellip;), frameworks etc
there is no clear direction on how to test an application. Same applies for any PHP application, where you have
many frameworks, methods and styles to choose from. In this blog post I will shed some light on how to get started
with &ldquo;Unit&rdquo; testing in a Laravel application. Laravel has gained lots of popularity in the past years may be due to its
simplicity, ease of use, clear documentation and availability of packages/libraries.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-unit-tests/laravel-popularity.png" title="Laravel is very popular" alt="Laravel is very popular"></p>

<!-- more -->


<h2>Introduction</h2>

<p>A general issue with PHP Frameworks is that for framework code they always use unit testing and in the documentation for
applications using the framework they document and support using functional testing. It makes sense in a way that the framework
code is general and the application code is specific but it should also be clearly mentioned that the code can be
tested in a unit test fashion and not only on how it is rendered in a browser. Same goes for laravel the framework
tests are <a href="https://github.com/laravel/framework/blob/5.1/tests/View/ViewBladeCompilerTest.php">Unit</a> test and the
documentation for application tests are for <a href="http://laravel.com/docs/5.1/testing">functional</a> test.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-unit-tests/laravel-testing-doc.png" title="Laravel application testing doc" alt="Laravel application testing doc"></p>

<h2>Qualities of Unit tests</h2>

<p>Unit tests should test only one method or be focus on one class and not take into account the dependencies. All the
dependencies should be mocked and only the class/method under test should be tested if it works as expected. Some
qualities of unit tests are:</p>

<ol>
<li>It should test only one specific part of the application generally a method/class.</li>
<li>It should be simple and verify only the specific part under test (single unit of work)</li>
<li>It should not depend on external data</li>
<li>It should not dependent on external resources like file system, database etc</li>
<li>It should not depend on particular order and be isolated, so you could even run it in parallel</li>
</ol>


<p>The above 5 characteristics make it easy to setup and super fast when you run as there are no external dependencies
like a database or file system.</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-unit-tests/laravel-unit-tests.png" title="Laravel unit tests" alt="Laravel unit tests"></p>

<h2>More on Unit testing</h2>

<p>Unit tests is about writing testable code, if your functions are 50 odd lines and your classes are 1000+ lines writing
unit tests for them will be a pain. If the code is well structured and broken down into logical classes and method
writing unit tests will be a breeze.</p>

<h2>Unit testing in Laravel</h2>

<p>In case of Laravel, you can follow your own structure and make the controllers very slim and use services where the
domain/business logic can reside. For this example I will use a checkout example with following conditions:</p>

<ol>
<li>If the payment method is Cash, it will add 5.0 as Cash on Delivery Fee</li>
<li>For all other payment methods the Cash on Delivery Fee will be 0.0</li>
</ol>


<h2>New Laravel Structure and steps</h2>

<p>We will structure the Laravel application as:</p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-unit-tests/laravel-unit-test-structure.png" title="Laravel unit test application structure" alt="Laravel unit test application structure"></p>

<p>For the above case we will do the following to achieve unit testing with a structure having Service as below:</p>

<ul>
<li>Get a basic laravel set up with <code>composer create-project laravel/laravel --prefer-dist</code></li>
<li>Add a <a href="https://github.com/geshan/laravel-unit-test-example/blob/master/app/Services/Checkout.php">Checkout service</a> at <code>App\Services\Checkout</code>, write relevant code to fulfill above requirements.</li>
<li>Add the checkout service as a container service in <a href="https://github.com/geshan/laravel-unit-test-example/blob/master/app/Providers/AppServiceProvider.php#L27">App\Providers\AppServiceProvider</a> with
<code>php
public function register()
{
  $this-&gt;app-&gt;instance('Checkout', new Checkout());
}
</code></li>
<li>Add a <a href="https://github.com/geshan/laravel-unit-test-example/blob/master/app/Http/Controllers/CheckoutController.php">Checkout controller</a> at <code>App\Http\Controllers</code></li>
<li>Add a route <code>/place</code> in <a href="https://github.com/geshan/laravel-unit-test-example/blob/master/app/Http/routes.php#L19">app/Http/routes.php</a> as
<code>php
Route::get('/place/{paymentMethod}', [
  'as' =&gt; 'order-place', 'uses' =&gt; 'CheckoutController@placeOrder'
]);
</code></li>
<li>Change the <a href="https://github.com/geshan/laravel-unit-test-example/blob/master/composer.json#L26">composer.json</a> to have namespace in tests.</li>
<li>Add <a href="https://github.com/geshan/laravel-unit-test-example/blob/master/tests/Services/CheckoutTest.php">test class</a> for the newly added Checkout service at <code>Test\Services\CheckoutTest</code>, write relevant test.</li>
<li>Run the unit tests <code>./vendor/bin/phpunit</code> they are green in a matter of seconds, smile :)</li>
</ul>


<p>This is a very simple example without mocking and using methods like <code>$this-&gt;mockedObj-&gt;shouldReceive('mockedMethod')-&gt;once()</code>, it
is a getting started post not a deep dive :).</p>

<p>You can have a look on how I did it with the <a href="https://github.com/geshan/laravel-unit-test-example/commits/master">github commits</a>.
You might be thinking we could do it tests first full TDD style, in my opinion having tests count how you add them is
up to you. It&rsquo;s great to write tests first but it takes time to come to that level so rather then not having tests at
all I would opt for having tests after code. Below is example of the test code with use of <a href="http://bit.ly/1Fe0cwx">data providers</a>:</p>

<pre><code class="php">
/**
     * Data provider for testCalculateTotal
     * variables are in the order of
     * $paymentMethod, $expectedTotal
     *
     * @return type
     */
    public function paymentMethodProvider()
    {
        return [
            ['Cash', 100.00],
            ['Credit Card', 95.00]
        ];
    }

    /**
     * Test to check if the order total is calculated correctly
     * for given payment method.
     *
     * @param string $paymentMethod
     * @param float $expectedTotal
     *
     * @dataProvider paymentMethodProvider
     */
    public function testCalculateTotal($paymentMethod, $expectedTotal)
    {
        $this-&gt;assertEquals(
            $this-&gt;checkout-&gt;calculateTotal($paymentMethod),
            $expectedTotal,
            sprintf('Testing total calculation for %s.', $paymentMethod)
        );
    }
</code></pre>

<p><strong>The full running app with tests is available as an open source repository on <a href="https://github.com/geshan/laravel-unit-test-example/">github</a>.</strong></p>

<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-unit-tests/running-laravel-app.png" title="Running Laravel app with PHP server" alt="Running Laravel app with PHP server"></p>

<h3>Tip</h3>

<blockquote>
I found using `gulp tdd` quite interesting, specially as the tests were super fast. 

All I needed to do was change the provided gulp file with `mix.phpUnit();` and run `gulp tdd` then on 
each change my tests would automatically run and I would see the green or red desktop notification too. Quite handy.
</blockquote>


<p><img class="center" src="https://geshan.com.np/images/generic/loading.gif" data-echo="/images/laravel-unit-tests/tests-green-gulp.png" title="Handy gulp tdd for Laravel" alt="Handy gulp tdd for Laravel"></p>

<h2>Choice of Tools and services</h2>

<p>For testing with Laravel I would recommend the following tools:</p>

<ol>
<li><a href="https://phpunit.de/">PHPUnit</a> Framework, even though BDD with <a href="http://www.phpspec.net">PHPSpec</a> is getting some
traction but only a handful of frameworks or systems are using PHPSpec. PHPUnit is still very popular.</li>
<li>For mocking use <a href="https://github.com/padraic/mockery">Mockery</a>, here as well <a href="https://github.com/phpspec/prophecy">Prophecy</a>
looks like a better option but then you will have issues with mocking static methods of eloquent models in case of Laravel.</li>
<li>Unit testing with PHP is a puzzle and Continuous Integration (CI) is the missing piece, there by if you are doing
an open source project I would suggest <a href="https://travis-ci.org/">Travis CI</a> which costs nothing and for a private project
<a href="http://shippable.com">Shippable</a> is a good CI service for free.</li>
</ol>


<h2>Conclusion</h2>

<p>As Martin Fowler emphasizes in his <a href="http://martinfowler.com/bliki/TestPyramid.html">test pyramid</a> we should always give
priority to more unit tests which will eventually strengthen the integration/functional tests we write for our project.
I don&rsquo;t believe that only having unit tests will remove the need of having functional tests still good unit test which
covers not only the code also its use cases will surely be a boon. Happy Unit testing!</p>
]]></content>
  </entry>
  
</feed>
